<!DOCTYPE HTML>
<html>
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
</head>
<body>
<pre>
代码片段 (笔试题): [codesandbox.io](https://codesandbox.io/s/zpjo211yp) ([codepen.io](https://codepen.io/))

- 从输入URL到页面加载完成 http://fex.baidu.com/blog/2014/05/what-happen/
- js 算法 https://github.com/trekhleb/javascript-algorithms
- js秘密花园 http://bonsaiden.github.io/JavaScript-Garden/zh/
- 33-js-concepts https://github.com/leonardomso/33-js-concepts
- 只在行首字符是 +、-、[、(、/ 这5种情况下，加前置分号即可。
- [蚂蚁前端框架和工程化](https://github.com/sorrycc/blog/issues/85)

- ES 与 CommonJS modules 的区别
  - 静态化，支持静态分析，编译时就能确定模块的依赖关系，以及输入和输出的变量。能支持引入宏（macro）和类型检验（type system）。CommonJS 和 AMD 模块，都只能在运行时确定。
  - `import`、`export`可以出现在模块的任何位置，但要处于模块顶层，不能放在块级作用域内。
  - CommonJS 模块输出的是一个值的拷贝（输出后不可变），而 ES6 模块输出的是值的引用（输出后可变）。
  - ES6 模块支持“循环依赖”，正常输出。CommonJS 模块也支持，但只输出已经执行的部分，还未执行的部分不会输出。

- [WebAssembly](https://juejin.im/entry/5b20d09d6fb9a01e242490b1)
  - WebAssembly 并不是一门编程语言，而是一份字节码标准。
  - 各种复杂的计算：图像处理、3D运算(大型 3D 网页游戏)、语音识别、音视频编码解码。区块链合约。
  - React 的 dom diff、RN 对 JavaScriptCore 的使用。
  - [madewithwebassembly](https://madewithwebassembly.com/)、eBay 的[条形码扫描](https://www.infoq.cn/article/vc*q7psQqWMaVU8igJeD)、[Google earth web](https://earth.google.com/web/) 版、[autocad](https://web.autocad.com/login) web 版

- [PWA](https://developers.google.com/web/progressive-web-apps/)
  - webapp 给 app 引流拉新，而 native app 体验好，用来保活。[渐进增强的 Web 体验（Progressive Web AMP）](https://zhuanlan.zhihu.com/p/24749809)
  - [pwabuilder](http://www.pwabuilder.com/)、[amp](https://www.ampproject.org/)、[How AMP achieves its speed - Google I/O 2016](https://www.youtube.com/watch?v=cfekj564rs0)
  - Service Worker 需要运行于 HTTPS 或本地 localhost 环境，是继 Web Worker 后又一个新的线程。来实现离线页面功能。
  - Service Worker 是独立于页面的一个运行环境，它在页面关闭后仍可以运行。Web Worker 在页面关闭后不再运行。
</pre>

<pre>
## redux & react
react 需要遍历或修改 children，要使用`React.Children.forEach / React.Children.map` 方法，而不要用`Array.isArray(children) / children.forEach`等方法。

不可变的数据更新模式 [官方文档](https://redux.js.org/recipes/structuring-reducers/immutable-update-patterns) ([翻译](https://cn.redux.js.org/docs/recipes/reducers/ImmutableUpdatePatterns.html))

[解读 redux 的设计思路与用法](http://div.io/topic/1309)、[UI state应该放到哪里？](https://github.com/rackt/redux/issues/595)
[Smart and Dumb Components](https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0)、[Reactive programming vs Passive programming](https://vaibhavgupta.me/2017/12/31/reactive-programming-vs-passive-programming/)

- reactive :: Action -> Model -> Model（Model, Side Effects(异步消息)）[elm-architecture](https://github.com/evancz/elm-architecture-tutorial/)
- React.js 本质：`(state, props) => state` (render :: Model -> UI)
- flux 本质：`(state, action) => state` (redux 的 reducer)。 不同的 component 维护许多各自不同 state，导致数据碎片化，flux 模式利用顶层 store 能解决这个问题。

### redux 概念

- actions 其实就是 mutations，即 ui 或者 server 的 response。
- action creator 调用 dispatcher (passive)，传递 mutations。
    - dispatcher 是一个 pub-sub systems。
- store 监听 actions 再去 mutate data。
    - Only Store gets to decide how to update the data。
- component 监听 store。Views subscribe to the stores that contain the data that it needs。

### redux & redux-saga 典型流程
form 表单提交，触发 FORM_POST action，saga 里 `yield put` POST_SUCCESS 触发 action，改变页面状态或拉取新数据，触发 UI CHANGE 的 action，过程中用 `yield select` 从 state 里选取需要的参数。

### [PureComponent](https://reactjs.org/docs/react-api.html#reactpurecomponent)

- 父组件是 pure component，子组件也需要是 pure component。因为父组件的 state 和 props 保持不变时是不会重新渲染的，子组件也就不会重新渲染了。
- 除非碰到了性能问题，不然不要用 PureComponent。遇到性能问题，也可以通过自己定制 shouldComponentUpdate 来控制。
- 如果预期到某个组件的 props 或是 state 会「频繁变动」，那就不用使用 PureComponent，因为这样反而会变慢。示例：
<!-- 
render() {
  // 每次传入的 style 都是一个新对象，Post 组件每次都需要 rerender，
  // 不需要使用 PureComponent 会再多一次 props 和 state 的对比。
  return <Post item={item} style={{ 'width': 120 }} />;
} -->

### setState
[3 Reasons why I stopped using React.setState](https://medium.com/@mweststrate/3-reasons-why-i-stopped-using-react-setstate-ab73fc67a42e#.o2lwoysxh) 

- setState 是异步的 [state-updates-may-be-asynchronous](https://facebook.github.io/react/docs/state-and-lifecycle.html#state-updates-may-be-asynchronous) / [示例](https://stackoverflow.com/a/45249445/2190503)
- setState 引起不必要的 render。
- setState 不能覆盖所有的组件状态（像生命周期的钩子、timers、events）。

### diff & key

- [虚拟DOM Diff算法解析](http://www.infoq.com/cn/articles/react-dom-diff)
- [Dynamic Children - Why the Keys are Important](http://blog.arkency.com/2014/10/react-dot-js-and-dynamic-children-why-the-keys-are-important/)

dom 对象是很庞大的（上边有很多属性），其创建的开销比较大，已有的 dom 对象上做更新开销并不大，众多框架都在围绕此做优化，比如用`key`是否变化来判断对 dom 的操作是 “更新” 还是 “销毁重建”。
dom批量更新：dom操作如，1.删除一个元素，2.增加一个元素，3.在增加的元素上改变一个属性。
如果用 dom-api 一步步操作，会导致中间多次的 repaints 和 reflows，这是比较低效耗性能的。
如果放到「虚拟 dom」上操作，会把这三个过程最终的结果，一次更新到实际 dom 树上，只用操作一次实际 dom。
react virtual-dom 里一次 digest 中的 diff 只需一次，但是会随着 ui 的复杂度，性能损耗严重，virtual-dom 与原 dom 的对应也更难 (如果 angular 的脏检查的性能取决与 watcher 的数量，那 react 则是取决与 ui 规模)。 virtual-dom 的内部结构变化是不可预知的

- [真实 DOM 和 react 虚 dom 讨论](http://www.zhihu.com/question/31809713)
- [React Virtual DOM vs Incremental DOM vs Ember’s Glimmer: Fight](https://auth0.com/blog/2015/11/20/face-off-virtual-dom-vs-incremental-dom-vs-glimmer/)

</pre>

<script>

  // 变量提升
  var x = 1; // Initialize x
  var y; // Declare y
  console.log(x + " " + y); // '1 undefined'
  y = 2; // Initialize y

  var name = 'World!';
  (function () {
    // var name; 相当于多了这个
    if (typeof name === 'undefined') {
      var name = 'Jack';
      console.log('Goodbye ' + name);
    } else {
      console.log('Hello ' + name);
    }
  })();

  // 局部变量和全局变量
  (function(){
    var x = y = 1;
  })();
  console.log(y);
  console.log(x);

  // 数组去重
  let array=[0,3,4,5,3,4,7,8,2,2,5,4,6,7,8,0,2,0,90];
  [...new Set(array)]

  // var 与 let 区别
  const Greeters = []
  for (let i = 0 ; i < 10 ; i++) {
    Greeters.push(function () { return console.log(i) })
  }
  Greeters[0]() // 0
  Greeters[1]() // 1
  Greeters[2]() // 2


  /**
  闭包：利用的是 “高阶函数” 的特性：函数可以作为参数或者返回值。
  */
  var fn = function(i) {
    // 局部变量 i 由于被 fun 引用，即便 fn 执行完毕，但也不会被 垃圾回收。
    return function() {
      console.log(i++);
    };
  };
  var fun = fn(2);
  fun();
  fun();

  for (var j = 0; j < 3; j++) {
    setTimeout(() => console.log(j), 1000);
    (function(j) {
      setTimeout(() => console.log(j), 3000);
    })(j);
  }

  /* Function
  JS 中的函数运行在它们被定义的作用域里, 而不是它们被执行 (调用) 的作用域里。
  JS 引擎不是一行行执行，而是一段段（不同 Script 标签为不同段落）的分析执行，
  不同 script 里的相同函数定义互不影响。

  - [匿名函数的多种调用方式](http://www.cnblogs.com/snandy/archive/2011/02/28/1966664.html)
  - [立即调用的函数表达式](http://www.cnblogs.com/TomXu/archive/2011/12/31/2289423.html)
  - [ECMA-262-3 in detail. Chapter 5. Functions](http://dmitrysoshnikov.com/ecmascript/chapter-5-functions/)

  匿名函数 http://www.cnblogs.com/TomXu/archive/2011/12/31/2289423.html
  http://dmitrysoshnikov.com/ecmascript/chapter-5-functions/#question-about-surrounding-parentheses
  */

  // ()里边语句为函数表达式
  (function() { console.log('括号在里边'); }());
  (function() { console.log('括号在外边'); })();
  // !后边语句也要为表达式
  !function() { console.log('! 符号'); }();

  /*
    常用方法：call / apply / bind （要求能模拟实现 bind）
  */
  // call 是 Function 的实例方法还是静态方法？
  console.log(Function.call === Function.prototype.call);
  console.log(typeof Function.prototype); // function
  
  function demo () {
    // [].slice.call(arguments); // 写法是否合适？
    console.log(Array.prototype.slice.call(arguments));  // 将 arguments 转换为数组对象
    // 最常见的 “类数组对象” 就是 function 的 arguments 对象和 dom 集合。
    // Array.prototype.slice.call 只能将 arguments 转换为数组，但是对 dom 集合却不可以

    var slice = Array.prototype.slice.call;
    console.log(slice([1, 2, 3], 1)); // TypeError 是否跟 this 有关？
  }
  demo(1, 2, 3);
  

  /*
    严格模式 / 非严格模式
  */
  window.color = "red";
  function sayColor() {
    "use strict";
    console.log(this); // 严格模式下 undefined
    console.log(this.color); // 严格模式下，this 默认不会指向 window
    someUndeclaredVar = "foo"; // 防止产生意外的全局变量
    console.log(arguments);
  }
  sayColor();
  sayColor.call(window);
  sayColor.call(undefined);
  sayColor.call(null);
  
  function Person(name) {
    "use strict";
    this.lastName = name;
  }
  // 严格模式下、没有 new 时、构造函数里 this 值为 undefined，由于不能给 undefined 添加属性，会抛出错误。
  // 非严格模式下，没有 new 时、this 是全局对象。
  var me = new Person("Nicholas"); 


  /*
    undefined & null
  */
  var jsonObj = {
    a: undefined,
    b: null,
    c: false,
    d: true,
    e: 2
  };
  console.log(JSON.stringify(jsonObj));

  // undefined 是不可靠的，可用 void 0 代替：http://shapeshed.com/the-void-of-undefined-in-javascript/
  console.log(void 0 === undefined);
  function isUndefined(obj) {
    return obj === void 0;
  }
  console.log(null == undefined == '' == 0 == 0.0 == -0 == false);

  console.log(window.localStorage != undefined, typeof window.localStorage != 'undefined') // 判断不完善
  console.log('localStorage' in window && window['localStorage'] != null) // 完善

  console.log('undefined' in window); // undefined 默认值为 'undefined'
  var anObj = {};
  console.log('undefined' in anObj); // false

  // undefined 是 window 上的一个属性，但 null 不是, null 是空对象的直接量
  console.log(window.undefined === undefined);
  console.log(window.null === undefined, null !== undefined, window.null === null);

  var undefined = 8; // 老浏览器上，window.undefined 是可以覆盖的，新浏览器不允许覆盖。
  (function(window, undefined) {
    // 在老浏览器上：这里第二个参数 undefined 作为真正的 undefined 使用
    console.log(undefined); // 此处 undefined 参数为局部的名称为 undefined 变量，值为 undefined
    console.log(window.undefined); // 8 (老浏览器)
  })(window);

  var undefined = 6;
  (function () {
    'use strict'; // 试试切换严格模式
    console.log(undefined); // undefined
  })();

  (function (undefined) {
    // undefined 作为函数参数，是可变的
    'use strict';
    console.log(undefined);

    undefined = 12345;
    console.log(typeof undefined);
  })(-1);

  (function () {
    'use strict';
    try {
      undefined = 3;
      console.log(undefined);
    } catch (e) { console.log(e); }

    undefined = 2;
    console.log(undefined);
    
    var undefined = 4;
    console.log(undefined );
  })();


  /* Object 
  用 var anObject = new aFunction() 形式创建对象的过程实际上可以分为三步：
    1. 建立一个新对象（anObject）；
    2. 将该对象（anObject）的 __proto__ 设置为构造函数（aFunction）prototype 引用的那个原型对象；
    3. 将该对象（anObject）作为 this 参数调用构造函数，完成成员设置等初始化工作。
  对象建立之后，对象上的任何访问和操作都只与对象自身及其原型链上的那串对象有关，与构造函数无关。
  */

  // 对象的创建过程示例
  function MyFunc() { }; // 定义一个构造函数
  var anObj = new MyFunc();
  // 等价于：
  var anObj = {};     // 创建一个对象
  anObj.__proto__ = MyFunc.prototype;
  MyFunc.call(anObj); // 将 anObj 对象作为 this 指针调用 MyFunc 函数


  // 实现 new 操作符 http://blog.vjeux.com/2011/javascript/how-prototypal-inheritance-really-works.html
  function New (f) {
    var n = { '__proto__': f.prototype };
    return function () {
      f.apply(n, arguments);
      return n;
    };
  }
  // 内置对象（Array、Number、Object）的 prototype 不能被改变。
  Array.prototype = {
    splice: function(){ console.log(11); }
  };
  var arr = [];
  console.log(arr instanceof Array); // true, 说明 Array 的内置原型对象的引用还是保存着的
  console.log(arr.splice);


  var o = {
    x: 8,
    valueOf: function() {
      return this.x + 2;
    },
    toString: function() {
      return this.x;
    }
  };
  console.log(o + '1', o + 1); // "101" 11


  /* instanceof，判断对象是否是某个类的实例
    如果 obj instanceof Class 返回 true，那么 Class 的原型与 obj 原型链上的某个原型是同一个对象，
    但这并不意味着 obj 拥有 Class 的所有实例属性 (但肯定拥有 Class 的所有原型属性)。
  */
  console.log(1 instanceof Number, new Number(1) instanceof Number);
  // iframe 内 js 对象和父文档 js 对象是两套
  console.log(top.a instanceof Array, top.a instanceof top.Array);

  function t() {};
  t.prototype = Array.prototype;
  var x = new t();
  console.log(x instanceof t, x instanceof Array, x instanceof Object); // true 

  function Person(name) {
    this.name = name;
  }
  var p = new Person('a');
  console.log(p instanceof Person);

  Person.prototype = {};
  Person.prototype.constructor = Person;
  var q = new Person('a');

  console.log(p instanceof Person); // 一直为 false，因为p的原型链已经指向别处？
  console.log(q instanceof Person);


  /* Number
    Js 中所有数字都是浮点型
    NaN 类型 not a number NaN 自身和自身不相等，使用 isNaN() 函数判断 NaN 类型，原理是先调用对象的 valueOf() 方法，确定是否可以转换为数值，如果不能，基于这个返回值，再调用 toString() 方法，再测试返回值。

    parseInt() 方法有基模式，可以把 二进制、八进制、十六进制 或其他任何进制的字符串转换成整数，基是由方法的第二个参数指定。
    parseFloat() 原理和 parseInt() 解析方式相同，区别是只能解析 十进制 的值
   */
  console.log("10" * 5); // * - / 转换为整型，+ 转换为字符串
  console.log(5 / 0);  // Infinity
  console.log(-5 / 0);  // -Infinity
  console.log(0 / 0);  // NaN
  console.log(-4.3 % 2.1);  // 模运算符（%） -0.09999999999999964
  
  console.log(0.1 + 0.2 === 0.3); //false  浮点数精度丢失
  console.log(isNaN(10));     // false
  console.log(isNaN('10'));   // false
  console.log(isNaN(true));   // false
  console.log(isNaN('blue'));   // true
  console.log(isNaN(NaN));     // true

  // 数值转换。通过 Number 转换，如果是 null，返回 0；如果是 undefined 返回 NaN；
  console.log(Number('you'), Number(''), Number('0000011111'), Number(true));  // NaN 0 11111 1
  
  console.log(
    parseInt('12fuck'), parseInt(''), parseInt('sns'), parseInt('0000011111'), 
    parseInt('0xA'), parseInt(22.5), parseInt('70'), parseInt('070'), parseInt('0xf')
  ); // 12 NaN NaN 4681 10 22 70 56 15
  
  console.log(
    parseInt("19", 10), parseInt("11", 2), parseInt("17", 8), parseInt("1f", 16), parseInt("010")
  ); // 19 3 15 31 10或8
  console.log(
    parseFloat('1234fuck'), parseFloat('0xA'), parseFloat('070'), parseFloat('0808.5'),
    parseFloat('22.555.55'), parseFloat('3.11415926e7')
  ); // 1234 0 70 808.5 22.555 31141592.6


  /*
   Boolean 类型。通过使用 否 操作符两次，可以把一个值转换为布尔型。
   更多参考：http://www.w3school.com.cn/js/js_obj_boolean.asp
  */
  console.log(new Boolean());  // 0 null '' false NaN 这些值均为 false
  console.log(new Boolean(1));  // true 'false' 这些值均为 true
  console.log(!!'');  // false
  console.log(!!' ');  // true
  console.log(1 == true && 2 == true);


  /*  String 对象
    JavaScript 的字符串是不可变的（immutable），String 类定义的方法都不能改变字符串的内容。
    像 String.toUpperCase() 这样的方法，返回的是全新的字符串，而不是修改原始字符串。
    toString()方法转换为字符串，
    1. 调用每个值都有的toString()方法，toString可指定基数，默认为十进制, null和undefined没有这个方法
    2. 不知道转换值为null或undefined情况下 使用String()
  */

  console.log('a' == new String('a'));
  console.log(String.fromCharCode(255)); // Unicode 编码大于 255 就能确定是双字节

  // console.log(20013.toString());  // 报错
  console.log(20013..toString(2)); // 你没看错, 就是两个 .
  console.log((20013).toString(2));

  var bol = true;
  var num = 10;
  console.log(bol.toString());  // 'true'
  console.log(num.toString(2), num.toString(8), num.toString(10), num.toString(16));  // '1010' '12' '10' 'a'

  console.log(String(null), String(undefined));  // 'null' 'undefined'

  var s = 'test';
  s.len = 4; // 创建包装对象，为包装对象添加属性 len
  console.log(s.len); // 查找其len属性，返回 undefined
</p>

<!--<script src="http://code.jquery.com/jquery.js"></script>-->
<!-- <script src="http://ajax.googleapis.com/ajax/libs/jquery/1.11.0/jquery.min.js"></script> -->
<script src="https://a.alipayobjects.com/jquery/jquery/1.11.1/jquery-debug.js"></script>
<script>
  /*
  $('xx').data()使用地方 - [jQuery.data](http://www.cnblogs.com/silin6/p/jQuery_data.html)

  在实际应用中我们要给我们的 DOM 添加数据，如果我们给一个 DOM 添加的数据太多的话，会存在循环引用的风险，例如我们添加的数据恰好引用了这个 DOM 元素，就会存在内存的泄露。所以 jquery 使用了数据缓存的机制就解决或者说避免这一问题。

  我们想在 DOM 上添加数据，但是不想引起内存的泄露，也就是我们不想引起循环引用，要尽量减少在 DOM 上挂数据。
  jquery 的思路是这样：使用一个数据缓存对象 $.cache, 在需要绑定数据的 DOM 上扩展一个 expando 属性，这个属性存的是一个 id，这里不会存在循环引用的情况了，之后将数据存在 $.cache[id] 上，当我们取 DOM 上的数据的时候，我们可以根据 DOM 上的 expando 找到 id，进而找到存在 $.cache[id] 上的数据。
  可以看出 jquery 只是在 DOM 上扩展了一个属性 expando，数据都存在了 $.cache 中，利用 expando 这个属性建立 DOM 和缓存对象之间的联系。无论我们添加多少的数据都会存储在缓存对象中，而不是直接挂在 DOM 上。
  这个唯一 id 是一个整型值，初始为 0，调用 data 接口时自动加一，唯一 id 附加在以 $.expando 命名的属性上，$.expando 是动态生成的，类似于一个时间戳，以尽可能的避免与用户变量冲突。从匹配的 DOM 元素上取到唯一 id，在 $.cache 中找到唯一 id 对应的对象，再从对应的对象中找到 key 对应的值。

  es6 WeakMap 
  */

  // 初始化
  $(document).ready(function(){
      // 执行语句
  });
  相当于
  $(function(){
      // 执行语句
  });

  // 在 jQuery 下实现锚点的平滑跳转：
  $("html,body").animate({ scrollTop: $("#comment").offset().top}, 1000);
  // jQuery 插件开发
  jQuery.fn.xx = function(opts){
    var defaults = {
      x: xx
    };
    var opts = $.extend(op, opts);
    return $(this).each(function() {
      //...
    });
  }
</script>

<pre>
## 2013-08 兼容性问题
- IE8及以下，ajax请求地址和参数相同时，会在一段事件内，读取浏览器缓存的ajax返回文件数据，而不去重新请求。-- 解决：请求参数加时间戳  
- JSON.stringify 只支持IE8\9\10标准文档模式，考虑到文档设置有兼容性视图模式（IE67模式）需要对此方法做兼容（参考json2.js）  
- input、textarea的blur事件中删改页面元素，会影响作用区域周围的元素事件处理。例如：点提交btn，先触发了blur事件，改变btn周围的元素，使得btn位置变动，此时btn的事件处理函数不会触发，再点才可触发。
- IE8里在某个元素上设置`background: transparent;`，给此元素添加事件，并不会触发事件，像click mousedown事件
- IE9什么原因能导致input file框点击没反应？
</pre>

</body>
</html>
