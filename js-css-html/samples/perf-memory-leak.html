<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>interVal</title>
</head>
<body>
<pre style="white-space: pre-wrap;">
JavaScript 提升性能之移除空事件处理程序
这里，有一个按钮被包含在 div 元素中，为避免双击，单击这个按钮时就将按钮移除并替换成一条消息。
但问题在于，当按钮被从页面中移除时，它还带着一个事件处理程序呢，在 div 元素中设置 innerHTML 可以把按钮移走，
但事件处理各种仍然与按钮保持着引用联系。
有的浏览器（尤其是 IE）在这种情况下不会作出恰当的处理，它们很有可能会将对元素和事件处理程序的引用都保存在内存中。
如果某个元素即将被移除，那么最好手工移除事件处理程序。

在此，我们设置 div 的 innerHTML 属性之前，先移除了按钮的事件处理程序。
</pre>
  <div id="01">01</div>
  <button id="start_button">Start</button>
  <button id="destroy_button">Destroy</button>
  <script>
    var ele = document.getElementById('01');
    // var ele = document.querySelector('#01');
    ele.parentNode.removeChild(ele);
    // 因为有 js 变量 ele 引用 dom 节点，所以仍在内存中 (只是没在html文档里)
    console.log(ele);
  </script>
  <script>
    var Leaker = function () {};
    Leaker.prototype = {
      init: function () {
        this._interval = null;
        var self = this;
        this._interval = setInterval(function () {
          self.onInterval();
        }, 100);
      },
      destroy: function () {
        if (this._interval !== null) {
          clearInterval(this._interval);
        }
      },
      onInterval: function () {
        console.log("Interval", this);
      }
    };
    var leak;
    //var leak = new Leaker();
    document.getElementById("start_button").onclick = function () {
      if (leak !== null || leak !== undefined) {  // 此判断为何？不管leak是什么都对
        //return;
      }
      leak = new Leaker();
      leak.init();
    };
    document.getElementById("destroy_button").onclick = function () {
      leak.destroy();
      leak = null;
    };
  </script>
  <div id="test">0</div>
  <script>
    var interVal;
    interVal = setInterval(function () {
      var xhr = new XMLHttpRequest()
      xhr.open('GET', 'data.js', true)
      xhr.onreadystatechange = function () {
        if (this.readyState == 4 && this.status == 200) {
          document.getElementById('test').innerHTML++
        } else {
          xhr = null;
          clearInterval(interVal);
        }
      }
      xhr.send(null)
      xhr = null  //置为null避免内存泄露
    }, 50)
  </script>

  <div id="myDiv">
    <input type="button" value="Click Me" id="myBtn">
  </div>
  <script>
    var btn = document.getElementById("myBtn");
    btn.onclick = function () {
      btn.onclick = null;
      document.getElementById("myDiv").innerHTML = "Processing…";
    };
  </script>
</body>
</html>
