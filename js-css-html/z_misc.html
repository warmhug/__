<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Misc</title>
</head>
<body>
  <a href="https://zh.wikipedia.org/wiki/Lorem_ipsum">Lorem ipsum 乱数假文</a>
  <br>
  <a href="http://fex.baidu.com/blog/2014/05/what-happen/">从输入 URL 到页面加载完成的过程中都发生了什么事情？</a>
  <a href="https://github.com/trekhleb/javascript-algorithms">javascript-algorithms</a> 
  <a href="https://mp.weixin.qq.com/s/e-IC588SZPJK2QRBm3KuHA">2019年前端面试都聊啥？</a>
  <a href="https://mp.weixin.qq.com/s?__biz=MjM5MDE0Mjc4MA==&mid=2651011223&idx=2&sn=54acfe1d565f650c52fcea5481ad1195">今年最常见的前端面试题，你会做几道？</a>
  <a href="https://h5bp.github.io/Front-end-Developer-Interview-Questions/translations/chinese/">前端工作面试问题</a>
  <br>
  <a href="https://codesandbox.io/s/zpjo211yp">https://codesandbox.io/s/zpjo211yp</a>
  <style>
    /* 利用伪类清除浮动 */
    .clearfix {
      zoom: 1;
    }
    .clearfix:after {
      content: "";
      display: table;
      clear: both;
    }
  </style>
  <script>
    // 借助 __proto__ 实现数组的子类型
    var MyArrayProto = Object.create(Array.prototype);
    // var MyArrayProto = { __proto__:Array.prototype };
    MyArrayProto.foo = function () { };
    function createMyArray() {
      var arr = Array.prototype.slice.call(arguments);
      arr.__proto__ = MyArrayProto;
      return arr;
    }
    var myarr = createMyArray(1,2,3); // myarr会有foo方法,也会有其他的数组方法
    console.log(Object.getPrototypeOf(MyArrayProto) === Array.prototype);

    // 创建 People (父类) 和 Male (子类) 实现继承
    function People(name) { this.name = name; }
    People.prototype.getName = function () { console.log('name:', this.name); }
    function Male(name, sex) {
      // 这里的 call，只是调用父类的构造器，而父类构造器的 prototype 上的东西并没被处理
      People.call(this, name);
      this.sex = sex;
    }
    // Male.prototype = People.prototype; // 错误，这样对子类 Male 原型的修改，都直接会改变父类 People 的原型
    // 方法一：正确做法，但是父类 People 上属性可能比较多，使得占用内存大
    Male.prototype = new People();
    // 方法二：优化，利用一个空函数对象，减小内存占用
    var F = function() { };
    F.prototype = People.prototype;
    Male.prototype = new F();
    // 方法三：优化，使用 Object.create
    Male.prototype = Object.create(People.prototype);
    Male.prototype.constructor = Male;
    Male.prototype.getSex = function () { console.log('sex:', this.sex); }
    var male = new Male('jim', 'male');
    male.getName();
    male.getSex();
    // 父类修改，会影响所有子类
    People.prototype.getName = function () { console.log('parent，xxx'); }
    // 子类修改，不应该影响父类
    Male.prototype.getName = function () { console.log('sub，xxx'); }
    male.getName();
    var male1 = new Male('jim', 'male');
    male1.getName();
    male1.getSex();
    

    // 跨浏览器的 addEventListener 实现
    function addEventListener(target, eventType, callback) {
      if (target.addEventListener) {
        target.addEventListener(eventType, callback, false);
        return {
          remove: function () {
            target.removeEventListener(eventType, callback, false);
          }
        };
      } else if (target.attachEvent) {
        target.attachEvent('on' + eventType, callback);
        return {
          remove: function () {
            target.detachEvent('on' + eventType, callback);
          }
        };
      }
    }


    // 如何判断一个变量是对象还是数组？给出判断 数组 类型的两种以上方法
    var ins = [];
    var ins = {};
    console.log(Object.prototype.toString.call(ins));
    console.log(Array.isArray(ins)); // es5 Array.isArray()
    console.log(ins instanceof Array); // IE 兼容性
    console.log(typeof ins); // 不能使用 typeof 来判断对象和数组

    /**
     * 说明：实现一个方法，用于验证给定字符串是否为数字，注意充分考虑各种符合数字定义的字符串
     * 示例：
        isNumber('0') => true
        isNumber(' 0.1 ') => true
        isNumber('abc') => false
        isNumber('1 a') => false
        isNumber('2e10') => true
        isNumber('Infinity') => true
     */
    function isNumber(str) {
        /* 代码实现 */
      return !isNaN(str * 1)
    }

    // 检验对象是否循环引用
    var obj = { foo: { bar: {} } };
    obj.foo.bar = obj.foo;
    try {
      JSON.stringify(obj);
    } catch(e){
      console.log(e.message);
    }

    var user = {
      count: 1,
      getCount: function() {
        return this.count;
      }
    };
    console.log(user.getCount()); // what?
    var func = user.getCount;
    console.log(func()); // what? 
    // 怎么能访问到 user 的 count
    var func = user.getCount.bind(user);
    console.log(func()); // what? 


    /**
     * 怎么生成 类似以下结构的 tree 数据？(注意 id 的值需要反馈节点所在树的位置)
     [{
       id: '0',
       children: [{
         id: '0-0',
         children: [{
           id: '0-0-0',
         }, {
           id: '0-0-1'
         }]
       }, {
         id: '0-1'
       }]
     }]
     * 再写出 用 广度优先(BFS) 和 深度优先(DFS) 遍历以上树的方法？
     */
     // 生成 treeData 方法
     function generateTree(
       x = 3, // x: 每一级下的节点数
       y = 2, // y: 每级节点数里有 y 个节点、存在子节点 (y < x)
       z = 1 // z: 树的 level 层级数（0表示只有一级）
      ) {
        const treeData = [];
        function _loop(level, preKey = '0', nodes = treeData) {
          const _level = level - 1;
          if (level < 0) {
            return nodes;
          }
          for (let i = 0; i < x; i++) {
            const key = `${preKey}-${i}`;
            if (i < y) {
              nodes.push({ id: key, children: _loop(_level, key, []) });
            } else {
              nodes.push({ id: key });
            }
          }
          return nodes;
        }
        _loop(z);
        return treeData;
    }
    const tree = generateTree(3, 2, 2);
    console.log(tree);
    // BFS
    function traverseBFS(callback, treeData) {
      let queue = [...treeData];
      while (queue.length) {
        const node = queue.shift();
        if (callback(node.id)) {
          return node;
        }
        queue = queue.concat(node.children); // Node is not target, add its children to the queue
      }
      return null; // No result found
    }
    console.log(traverseBFS(id => id === '0-0-1', tree));
    // DFS
    let selNode = '';
    function traverseDFS(callback, treeData) {
      const stack = [...treeData];
      for (let index = 0; index < stack.length; index++) {
        const node = stack[index];
        if (callback(node.id)) {
          selNode = node;
        }
        if (node.children && node.children.length) {
          traverseDFS(callback, node.children);
        }
        // return node;
      }
    }
    traverseDFS(id => id === '0-0-1', tree);
    console.log(selNode);


    // chrome 调试
    console.time('Timer1');
    var items = [];
    for(var i = 0; i < 100000; i++){
      items.push({index: i});
    }
    console.timeEnd('Timer1');


    // 删除数组元素
    var arr = [{done: false, val:1}, {done: true, val:2}, {done: true, val:3}, {done: false, val:4}];

    // 方法一：正向查找，删除后 index 减一
    // 注意：由于数组长度会变化，不能用 len = arr.length 存下最初数组长度 ！！
    for (var i = 0; i < arr.length; i++) {
      var o = arr[i];
      if (o.done) {
        // 删除一个元素，而 i 仍递增，如果不减一，会跨过一个元素
        arr.splice(i--, 1);
      }
    }
    console.log(arr);

    // 方法二：倒序查找删除
    var i = arr.length;
    while (i--) {
      if (arr[i].done) {
        arr.splice(i, 1);
      }
    }
    console.log(arr);

    // forEach 过程删除元素
    var nums = [0, 1, 2, 3, 1, 4, 5, 6];
    nums.forEach((i, index, arr) => {
      // console.log(i, index);
      if (i === 1) {
        // nums[index] = false;
        // arr.splice(index, 1) // 删除数组中一个，相当于 index + 1
        // nums.splice(index, 1) // 删除数组中一个，相当于 index + 1
        // console.log(i);
      }
    });
    // console.log(nums);


    // 数组去重
    // 性能最好
    var uniqueArray = function(arr) {
      for (var i = 0; i < arr.length - 1; i++) {
        var item = arr[i];
        for(var j = i+1; j < arr.length; j++ ) {
          item === arr[j] && (arr.splice(j, 1), j--);
        }
      }
      return arr;
    };
    // 性能次之
    function unique(arr) {
      var a = {}, b = {}, c = [];
      for (var i = 0; i < arr.length; i++){
        if (!b[a[i]]) {
            c[c.length] = arr[i];
            b[a[i]] = true;
        }
      }
      return c;
    }
    //字符串数组去除重复的项，即[‘1’,‘2’,‘1’,‘3’]——>[‘1’,‘2’,‘3’]
    function uniq(array) {
      return Array.from(new Set(array))
    }


    // [function currying](http://en.wikipedia.org/wiki/Currying)
    // 参考对比：
    // Function.prototype.bind
    var bind = function (fn, context) {
      var slice = Array.prototype.slice, args = slice.call(arguments, 2);
      return function () {
        return fn.apply(context, args.concat(slice.call(arguments)));
      }
    }
    var handler = function (x, y) {
      console.log(x, y);
    }
    var argh = bind(handler, undefined, 5, 10);


    // https://remysharp.com/2010/07/21/throttling-function-calls
    function debounce(fn, delay) {
      var timer = null;
      return function () {
        var context = this, args = arguments;
        clearTimeout(timer);
        timer = setTimeout(function () {
          fn.apply(context, args);
        }, delay);
      };
    }

    // https://remysharp.com/2010/07/21/throttling-function-calls
    function throttle(fn, threshold) {
      threshold = threshold || 200;
      var last, timeout;

      return function() {
        var now = +new Date();
        var args = arguments;
        var trigger = function() {
          last = now;
          fn.apply( this, args );
        }.bind( this );
        if ( last && now < last + threshold ) {
          // hold on to it
          clearTimeout( timeout );
          timeout = setTimeout( trigger, threshold );
        } else {
          trigger();
        }
      };
    }

    function ajax(url, success, fail) {
      var xhr = new XMLHttpRequest();
      xhr.onload = function() {
        if (xhr.status >= 200 && xhr.status < 400) {
          success(xhr.responseText);
        } else {
          fail(xhr);
        }
      };
      xhr.open("GET", url, true);
      xhr.send();
    }

    // 检测 滚动停止
    var delayedExec = function(after, fn) {
      var timer;
      return function() {
        timer && clearTimeout(timer);
        timer = setTimeout(fn, after);
      };
    };
    var scrollStopper = delayedExec(500, function() {
      console.log('stopped it');
    });
    // document.getElementById('box').addEventListener('scroll', scrollStopper);


    // 横竖屏状态检测
    var supportsOrientationChange = "onorientationchange" in window,
        orientationEvent = supportsOrientationChange ? "orientationchange" : "resize";
    window.addEventListener(orientationEvent, function () {
      switch (window.orientation) {
        case 0:
          alert('竖屏');
          break;
        case 90:
        case -90:
          alert('横屏');
      }
    });


    // navigator.userAgent  2015-12-02
    var ua = {
      edge: "Mozilla/5.0 (Windows NT 10.0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/42.0.2311.135 Safari/537.36 Edge/12.10240",
      IE11: "Mozilla/5.0 (Windows NT 6.1; WOW64; Trident/7.0; SLCC2; .NET CLR 2.0.50727; rv:11.0) like Gecko",
      IE10: "Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 6.1; WOW64; Trident/6.0; SLCC2; .NET CLR 2.0.50727)",
      IE9: "Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; WOW64; Trident/5.0; SLCC2; .NET CLR 2.0.50727)",
      IE8: "Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.1; WOW64; Trident/4.0; SLCC2; .NET CLR 2.0.50727; .NET4.0C; .NET4.0E)",
      chrome_win: "Mozilla/5.0 (Windows NT 5.2; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/41.0.2272.118 Safari/537.36",
      chrome_mac: "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/49.0.2578.3 Safari/537.36",
    };
    // 检测浏览器
    function browser(ua) {
      var tem;
      var M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];
      if (/trident/i.test(M[1])) {
        tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
        return 'IE '+(tem[1] || '');
      }
      if (M[1]=== 'Chrome') {
        tem= ua.match(/\b(OPR|Edge)\/(\d+)/);
        if(tem!= null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
      }
      M = M[2]? [M[1], M[2]]: [navigator.appName, navigator.appVersion, '-?'];
      if ((tem = ua.match(/version\/(\d+)/i))!= null) {
        M.splice(1, 1, tem[1]);
      }
      return M.join(' ');
    }
    // 只检测移动浏览器
    var browser = (function (ua) {
      var device = '', version = '', android, ipad, iphone;
      (android = ua.match(/(Android)\s+([\d.]+)/)) && (device = 'android') && (version = android[2]) ||
      (ipad = ua.match(/(iPad).*OS\s([\d_]+)/)) && (device = 'ipad') && (version = ipad[2].replace(/_/g, '.')) ||
      (iphone = !ipad && ua.match(/(iPhone\sOS)\s([\d_]+)/)) && (device = 'iphone') && (version = iphone[2].replace(/_/g, '.'));
      return {
        device: device,
        version: version.split('.'),
        mainVer: version.replace(/^(\d\.\d).*$/, '$1')
      };
    })(navigator.userAgent);
    //log(browser.device);
    //log(browser.version);
    //log(browser.mainVer);
  </script>
</body>
</html>