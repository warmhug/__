# js / css / html

代码片段：
[codepen.io](https://codepen.io/dashboard/) / 
[codesandbox.io](https://codesandbox.io/u/warmhug) / 
[jsfiddle.net](https://jsfiddle.net/user/dashboard/fiddles/)

- [前端技术清单](https://juejin.im/post/5bdfb387e51d452c8e0aa902)
- [33-js-concepts](https://github.com/leonardomso/33-js-concepts)
- [remote Collaboration](https://togetherjs.com/)
- [富文本编辑器 trix](https://github.com/basecamp/trix)
- [富文本编辑器技术演进](https://mp.weixin.qq.com/s/9gDI1r9aAu6dHJhXg34eIg)
- [富文本编辑器 braft-editor](https://github.com/margox/braft-editor)
- [Javascript-WYSIWYG-editors](https://github.com/cheeaun/mooeditable/wiki/Javascript-WYSIWYG-editors)

[WebAssembly](https://web.autocad.com/)
[Web 前端中的增强现实（AR）开发技术](https://geekplux.com/2018/01/18/augmented-reality-development-tech-in-web-frontend.html)、
[Chrome Experiments](https://experiments.withgoogle.com/collection/chrome)、
[Chrome Platform Status](https://www.chromestatus.com/features)、
[https://webkit.org/](https://webkit.org/)、
[airbnb/javascript](https://github.com/airbnb/javascript)、
[html5test](http://html5test.com/)、

[录制并回放 web 界面中的用户操作](https://github.com/rrweb-io/rrweb)(内网 xreplay)

- [代码演示文档生成器](https://www.docz.site/)
- [高性能无尽列表（元素可回收）](https://github.com/bvaughn/react-virtualized)
- [元素定位库](http://github.hubspot.com/tether/)

[现在的前端框架全是通过API获得数据，如何记录用户登录状态？](https://www.zhihu.com/question/301253397/answer/547887208) ([user-authentication-with-jwt](http://blog.leapoahead.com/2015/09/07/user-authentication-with-jwt/))

<https://tushuo.baidu.com/> /
<https://github.com/STRML/react-grid-layout> / [amcharts](http://www.amcharts.com/demos/)
<https://github.com/nfl/react-helmet>
<https://www.processon.com/>

- [front-end-application-frameworks-component-architectures](http://developer.telerik.com/featured/front-end-application-frameworks-component-architectures/)
- [一个对前端模板技术的全面总结](http://www.html-js.com/article/2313)
- [Web Components - building blocks of the future web](https://www.infinum.co/the-capsized-eight/articles/web-components-building-blocks-of-the-future-web)
- [开源前端框架纵横谈](http://www.csdn.net/article/2013-04-15/2814893)

浏览器检测：[ua检测](https://github.com/ded/bowser)、[特性检测](https://github.com/barisaydinoglu/Detectizr)

UI 库 & design

[primereact](https://www.primefaces.org/primereact/#/)、
[material-design](https://material.io/design/introduction/)、
[material-design-lite](https://github.com/google/material-design-lite)、
[fineui](http://fineui.com/)、[amazeui](http://amazeui.org/)、[miniui](http://www.miniui.com/)
[semantic-ui](http://semantic-ui.com/)、 [Flat-UI](http://designmodo.github.io/Flat-UI/)
[goodui](https://goodui.org/)、[weui](https://github.com/weui/weui)、[goratchet](http://goratchet.com/)

- [gulp 手册1](http://p.tb.cn/rmsportal_127_gulp_E6_89_8B_E5_86_8C1.pdf) / [gulp 手册2](http://p.tb.cn/rmsportal_127_gulp_E6_89_8B_E5_86_8C2.pdf)

- [你可能不需要jQuery](http://youmightnotneedjquery.com/)
- [js秘密花园](http://bonsaiden.github.io/JavaScript-Garden/zh/)、[全面基础教程](http://yanhaijing.com/basejs/)
- [静态资源版本更新与缓存](http://www.infoq.com/cn/articles/front-end-engineering-and-performance-optimization-part1)

- 只在行首字符是 `+、-、[、(、/` 这5种情况下，加前置分号即可，其他不用加分号。
- [Semicolons in JavaScript are optional](http://mislav.uniqpath.com/2010/05/semicolons/)
- [JavaScript 语句后应该加分号么？](http://www.zhihu.com/question/20298345/answer/14670020)

- [全面：观察者/pub-sub/facade/mvc、mvp、mvvm](http://addyosmani.com/resources/essentialjsdesignpatterns/book/)
- [中介者模式与观察者模式有何不同？](http://www.cnblogs.com/aaronjs/archive/2013/07/18/3199282.html)
- [Five Patterns to Help You Tame Asynchronous JavaScript](http://tech.pro/blog/1402/five-patterns-to-help-you-tame-asynchronous-javascript)
- [JavaScript 设计模式 – 第二部分： 适配器、装饰者和工厂模式](http://www.adobe.com/cn/devnet/html5/articles/javascript-design-patterns-pt2-adapter-decorator-factory.html)
- [Sea.js 源码解析（二）](https://github.com/lifesinger/lifesinger.github.com/issues/171)
- [Sea.js 源码解析（三）](https://github.com/lifesinger/lifesinger.github.com/issues/175)
- [json-server](https://github.com/typicode/json-server)
- [一切皆为 JavaScript](https://www.csdn.net/article/2013-11-04/2817389-JavaScript-World)

## react

[编写有弹性的组件](https://overreacted.io/zh-hans/writing-resilient-components/)、
[useEffect 完整指南](https://overreacted.io/zh-hans/a-complete-guide-to-useeffect/)

[react-typescript-cheatsheet](https://github.com/sw-yx/react-typescript-cheatsheet)

[React Fiber 是什么](https://zhuanlan.zhihu.com/p/26027085)、
[The how and why on React’s usage of linked list in Fiber to walk the component’s tree](https://medium.com/react-in-depth/the-how-and-why-on-reacts-usage-of-linked-list-in-fiber-67f1014d0eb7)、
[Inside Fiber: in-depth overview of the new reconciliation algorithm in React](https://medium.com/react-in-depth/inside-fiber-in-depth-overview-of-the-new-reconciliation-algorithm-in-react-e1c04700ef6e)、
[The introduction to Reactive Programming you've been missing](https://gist.github.com/staltz/868e7e9bc2a7b8c1f754)

[react isMounted 内存泄漏](https://reactjs.org/blog/2015/12/16/ismounted-antipattern.html)：Flux Redux 将整个 app 的状态储存在所有组件最外层，避免了组件的销毁影响整个 app 的 state。

生命周期 图示 dia­gram :
![https://tylermcginnis.com/an-introduction-to-life-cycle-events-in-react-js/](https://gw.alipayobjects.com/zos/rmsportal/KMqUOATjGIAemLuRLNWF.png)  
![http://www.cnblogs.com/twobin/p/4949888.html](https://gw.alipayobjects.com/zos/rmsportal/JRAlcAXhcdkagRIirtUP.jpg)

[3 Reasons why I stopped using React.setState](https://medium.com/@mweststrate/3-reasons-why-i-stopped-using-react-setstate-ab73fc67a42e#.o2lwoysxh) /

- setState 是异步的
  - [state-updates-may-be-asynchronous](https://facebook.github.io/react/docs/state-and-lifecycle.html#state-updates-may-be-asynchronous) / [示例](https://stackoverflow.com/a/45249445/2190503)
- setState 引起不必要的 render
- setState 不能覆盖所有的组件状态（像生命周期的钩子、timers、events）

### [PureComponent](https://reactjs.org/docs/react-api.html#reactpurecomponent)

相比使用 Component 多了以下代码，避免了 props 和 state 不变时组件的重新渲染（即 render 函数不会执行、也就不会触发 react 内部的 virtual DOM diff、节约了计算）。

```js
shouldComponentUpdate(nextProps, nextState) {
  return !shallowEqual(this.props, nextProps) || !shallowEqual(this.state, nextState);
}
```

- 父组件是 pure component，子组件也需要是 pure component。因为父组件的 state 和 props 保持不变时是不会重新渲染的，子组件也就不会重新渲染了。
- 除非碰到了性能问题，不然不要用 PureComponent。遇到性能问题，也可以通过自己定制 shouldComponentUpdate 来控制。
- 如果预期到某个组件的 props 或是 state 会「频繁变动」，那就不用使用 PureComponent，因为这样反而会变慢。示例：

  ```js
  render() {
    // 每次传入的 style 都是一个新对象，Post 组件每次都需要 rerender，
    // 不需要使用 PureComponent 会再多一次 props 和 state 的对比。
    return <Post item={item} style={{ 'width': 120 }} />;
  }
  ```

### diff & key

- React.js does not need to have knowledge about what exactly changed. All it needs to know is whether the state changed at all or not.
- While immutability does not provide easier answers to a what exactly changed problem, it provides a great answer to the is it changed at all or not question.
- [虚拟DOM Diff算法解析](http://www.infoq.com/cn/articles/react-dom-diff)

- [Dynamic Children - Why the Keys are Important](http://blog.arkency.com/2014/10/react-dot-js-and-dynamic-children-why-the-keys-are-important/)
- 不能在组件内通过 props 获取 key 或 ref。
- React.Children.map 会修改 key, 而 this.props.children.map 不会，参考 demo 示例

dom 对象是很庞大的（上边有很多属性），其创建的开销比较大，已有的 dom 对象上做更新开销并不大，众多框架都在围绕此做优化，比如用`key`是否变化来判断对 dom 的操作是 “更新” 还是 “销毁重建”。

dom批量更新：dom操作如，1.删除一个元素，2.增加一个元素，3.在增加的元素上改变一个属性。
如果用 dom-api 一步步操作，会导致中间多次的 repaints 和 reflows，这是比较低效耗性能的。
如果放到「虚拟 dom」上操作，会把这三个过程最终的结果，一次更新到实际 dom 树上，只用操作一次实际 dom。

react virtual-dom 里一次 digest 中的 diff 只需一次，但是会随着 ui 的复杂度，性能损耗严重，virtual-dom 与原 dom 的对应也更难 (如果 angular 的脏检查的性能取决与 watcher 的数量，那 react 则是取决与 ui 规模)。 virtual-dom 的内部结构变化是不可预知的

- [真实 DOM 和 react 虚 dom 讨论](http://www.zhihu.com/question/31809713)
- [React Virtual DOM vs Incremental DOM vs Ember’s Glimmer: Fight](https://auth0.com/blog/2015/11/20/face-off-virtual-dom-vs-incremental-dom-vs-glimmer/)

### HOC

使用 HOC ([Higher-Order Components](https://facebook.github.io/react/docs/higher-order-components.html)) 代替 Mixins，[Mixins Considered Harmful](https://facebook.github.io/react/blog/2016/07/13/mixins-considered-harmful.html)

HOC 的缺点：

- Like any solution, higher-order components have their own pitfalls. For example, if you heavily use refs, you might notice that wrapping something into a higher-order component changes the ref to point to the wrapping component. In practice we discourage using refs for component communication so we don’t think it’s a big issue. In the future, we might consider adding ref forwarding to React to solve this annoyance.
- [HOC 里的实际的 Component 名字被覆盖掉，导致多层组件嵌套难以识别](https://github.com/ant-design/ant-design-mobile/blob/0.9.12/components/_util/touchableFeedback.tsx#L10)

### 处理 children

需要遍历或修改 children，要使用`React.Children.forEach / React.Children.map` 方法，
而不要用`Array.isArray(children) / children.forEach`等方法。
`React.Children.xx`方法里有类似递归调用（详细跟踪React源码里的`traverseAllChildrenImpl`方法）、
能自动解析类似这样的 children：

```html
<List.Body>
  <List.Item>收银员</List.Item>
  {[1, 2, 3].map((i, index) => (<List.Item key={index}>运营</List.Item>))}
</List.Body>
```

而自己写的`Array.isArray`等如果不递归解析、就会把上段代码解析错误。

## 函数式编程

- [函数式编程](http://coolshell.cn/articles/10822.html)
- [函数式编程有哪些优点？](http://www.nowamagic.net/academy/detail/1220540)
- [函数式编程扫盲篇](http://www.cnblogs.com/kym/archive/2011/03/07/1976519.html)
- [函数式编程初探](http://www.ruanyifeng.com/blog/2012/04/functional_programming.html)
- [introduction-functional-javascript](http://www.sitepoint.com/introduction-functional-javascript/)
- [Functional Programming in Javascript === Garbage](http://awardwinningfjords.com/2014/04/21/functional-programming-in-javascript-equals-garbage.html)
- [使用JavaScript实现“真·函数式编程”](http://jimliu.net/2015/10/21/real-functional-programming-in-javascript-1/)

对象是面向对象的第一型，那么函数式编程也是一样，函数是函数式编程的第一型。

在纯粹函数式程式语言中，你不是像命令式语言那样命令电脑「要做什么」，而是通过用函数来描述出问题「是什么」。
递回在 Haskell 中非常重要。命令式语言要求你提供求解的步骤，Haskell 则倾向于让你提供问题的描述。
这便是 Haskell 没有 while 或 for 循环的原因，递回是我们的替代方案。

在面向对象编程中，我们把对象传来传去，那在函数式编程中，我们要做的是把函数传来传去，我们把他叫做 **高阶函数**
在函数式编程中，函数是基本单位，是第一型，他几乎被用作一切，包括最简单的计算，甚至连变量都被计算所取代。
在函数式编程中，变量只是一个名称，而不是一个存储单元，这是函数式编程与传统的命令式编程最典型的不同之处。

### Persistent data structure

Immutable data structures：当一个对象被创建之后、就永远不会变了，如果需要改变、就只能创一个新的。

```js
const obj = { text: 'hello' };
obj.text = 'world' // 这样不行，因为改变了 obj 这个对象
const newObj = { ...obj, text: 'world' }; // 必须要创建一个新对象
```

- [Immutability in JavaScript](http://www.sitepoint.com/immutability-javascript/)
- [Persistent_data_structure](https://en.wikipedia.org/wiki/Persistent_data_structure)

> fb出品的 [immutable-js](http://facebook.github.io/immutable-js/) 提供了 Immutable 的 List, Stack, Map 等数据结构，为了实现不可变性，最直接的做法可能是直接拷贝对象，但因为效率太低不可行，而是利用了 structural sharing，
这样就可以最小化的拷贝对象的一部分。拷贝的是哪一部分呢？如图：

[wiki 图示](https://upload.wikimedia.org/wikipedia/commons/thumb/5/56/Purely_functional_tree_after.svg/876px-Purely_functional_tree_after.svg.png)

这样嵌套的深层对象，只需拷贝f、g、d这一个链，其他的结构共享，这样创建了一个新对象，
就达到了 immutable 的目的，而且效率和内存占用都比较合理。但注意一个问题[Circular references](https://github.com/facebook/immutable-js/issues/259)，这个问题在 Haskell 等语言中在语言层面被解决了，
但在js中似乎难以解决。[详解视频](https://www.youtube.com/watch?v=I7IdS-PbEgI)

> Structural sharing is a powerful concept, and is what enables Clojure persistent data structures to achieve O(log n) performance on operations that would otherwise require full O(n) copies of a data structure.

## redux

- [UI state应该放到哪里？](https://github.com/rackt/redux/issues/595)
- [解读 redux 的设计思路与用法](http://div.io/topic/1309)

redux & redux-saga 场景:

form 表单提交，触发 `FORM_POST` action，
saga 里触发（ yield put ）`POST_SUCCESS`/`POST_FAILURE` action，
无论提交成功或失败，都需要改变页面状态、或拉取新的列表数据，触发 `UI_CHANGE`/`PULL_DATA` action，
`UI_CHANGE`/`PULL_DATA` 需要参数，用 `yield select` 从 `state` 里选取需要的数据（ ui状态数据需要存到全局 state 里），
复杂场景下、需要在 saga 里对来自不同 action 的数据结果做比对、筛选等操作，再触发最终的 action（比如 步骤条的下一步）。

### flux

不同的 component 维护许多各自不同 state，导致数据碎片化，flux 模式利用顶层 store 能解决这个问题

[本质：(state, action) => state](https://speakerdeck.com/jmorrell/jsconf-uy-flux-those-who-forget-the-past-dot-dot-dot)

[Smart and Dumb Components](https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0)

- Stores hold data, and signal when something has changed
- Views subscribe to the stores that contain the data that it needs

actions 其实就是 data，或者我认为是 mutations，即 ui 或者 server 的 response。
action creator 是一个 help method，调用 dispatcher，传递 mutations。所以，action creator 是直接调用 dispatcher (passive) 的。
dispatcher 是一个 pub-sub systems。
component 直接调用 action creator
store 监听 action creator
component 监听 store

In Flux, Store is the only place in your whole app that has privilege to mutate the data. It has no setters and only responds to actions emitted by the components. API responses are also actions, as they serve as inputs to Store. Only Store gets to decide how to update the data. Neither the UI nor other models should be able to mutate the data.

#### FRP (Functional Reactive Programming)

The former is Passive programming, while the latter is Reactive programming

- 展现：render :: Model -> UI
  - render 是一个接受一个数据模型参数并返回一个用户界面的函数。
  - React.js 本质：`(state, props) => state`
- 响应：reactive :: Action -> Model -> Model（Model, Side Effects(异步消息)）
  - reactive 是一个接受一个动作（事件）参数和一个模型，并返回一个新的模型的函数。
  - 有「Side Effects(异步消息)」时，reactive :: Action -> Model -> (Model, Effects Action)。参考 <https://github.com/evancz/elm-architecture-tutorial/>
  - flux 本质：`(state, action) => state` redux 的 reducer 也是这样。
- render 和 reactive 反复迭代即得到一个用户应该看到并可以操作的用户界面。

### 服务端渲染

`ReactDOMServer.renderToString()`执行时间、一般复杂的页面需要 20~50ms。数据如果是全局变量，用户并发访问服务器、就可能拿到了同一份数据，需要通过 uuid 来做标记，比较麻烦。redux 的 store 是一个通过函数构造的，数据是函数的参数，作为初始化数据，数据不是全局变量，没问题。函数式无副作用、无状态，利于并发。- @翰文
高并发的应用，不推荐使用 react 服务器渲染，因为性能不算好，会拉低应用的 qps 。

## 调试

- [Chrome DevTools’ Workspaces、Redirect 和 Fiddler / Charles 的使用](https://aarontgrogg.com/blog/2015/03/24/how-to-replace-remote-files-with-local-files-when-debugging/)
- [XSwitch](https://github.com/yize/xswitch) 原理是通过 chrome.webRequest API 来对请求进行劫持。
  - 代理到本地的，推荐写 `127.0.0.1` 而不是 `localhost`。HTTPS 下的页面访问了 http://127.0.0.1 的资源，不会被安全策略拦截。

## es6

- [ECMAScript compatibility table](http://kangax.github.io/compat-table/es6/)
- [迭代器和生成器 generators](http://se77en.cc/2014/01/20/iterators-and-generators-translation/)
- [es-modules 详解](https://jakearchibald.com/2017/es-modules-in-browsers/)
- [async await](https://developers.google.com/web/fundamentals/getting-started/primers/async-functions)
- [promise 使用问题](http://pouchdb.com/2015/05/18/we-have-a-problem-with-promises.html)
- [q](https://github.com/kriskowal/q)

### es6-modules

参考其他语言，如 Python 等模块设计。[es6-modules-final](http://www.2ality.com/2014/09/es6-modules-final.html)

- 静态化，支持静态分析，编译时就能确定模块的依赖关系，以及输入和输出的变量。能支持引入宏（macro）和类型检验（type system）。CommonJS和AMD模块，都只能在运行时确定。
- `import`、`export`可以出现在模块的任何位置，但要处于模块顶层，不能放在块级作用域内。
- 一个模块里`export deault`只能使用一次，其他输出可以用`export xx`。
- CommonJS模块输出的是一个值的拷贝（输出后不可变），而ES6模块输出的是值的引用（输出后可变）。
- ES6模块支持“循环依赖”，正常输出。CommonJS模块也支持，但只输出已经执行的部分，还未执行的部分不会输出。

## 性能

浏览器从服务器接收 HTML，把 HTML 在内存中转换成 DOM 树，在转换的过程中遇到：

- CSS 或 image 请求，不会阻塞 HTML 的解析、不需要等请求的返回，当返回后，只需要把返回的内容放入到 DOM 树中对应的位置。
- JS 请求。因为 JS 有可能直接改变 DOM 树结构，为了不重新构建 DOM 树，会阻塞其他的下载和浏览器渲染。
- 更多：[网页渲染过程](http://frontendbabel.info/articles/webpage-rendering-101/)、[JavaScript Loading Priorities in Chrome](https://addyosmani.com/blog/script-priorities/)、[让我们再聊聊浏览器资源加载优化](http://www.infoq.com/cn/articles/browser-resource-loading-optimization)

### 性能优化

工具：Chrome DevTools、<https://developers.google.com/web/fundamentals/performance/why-performance-matters/?hl=zh-cn>

[js 框架性能测试](https://github.com/krausest/js-framework-benchmark)
、[JavaScript内存泄露和CSS优化](https://github.com/zhansingsong/js-leakage-patterns)、[了解 JavaScript 应用程序中的内存泄漏](http://www.ibm.com/developerworks/cn/web/wa-jsmemory/index.html)

html 优化：

- 根据关键渲染路径、首先加载最小可用的 css js 资源，script 标签可以用 async 标记。[分析关键渲染路径](https://developers.google.com/web/fundamentals/performance/critical-rendering-path/analyzing-crp?hl=zh-cn)
- 在 head 里面尽量不引入 js, CSS 下面不能有任何的 JS 标签（包括内联JS），否则会阻塞 HTML 的解析。如果必须要在头部增加内联脚本，一定要放在 CSS 标签之前。[WebView性能、体验分析与优化](http://tech.meituan.com/WebViewPerf.html)
- repaint：当某元素在不改变布局、发生显示/隐藏的变化时，就会发生 repaint。
- reflow：当 DOM 以一种影响到布局的方式进行操作时，会触发 reflow。例如，样式改变影响了布局、className 改变、浏览器窗口大小改变、插入一个新元素、改变文本、新增一个元素属性。当元素 reflow 时，他的子节点和其后的任何元素也会reflow，最后所有元素进行 repaint。通过 getComputedStyle、offsetWidth、scrollWidth、clientWidth 等属性获取元素的尺寸或位置，会强行触发 reflow。
- 减少 reflow 的方法：
  - 多 style 变化可通过设置一次 className 完成。
  - 将多个元素改变都在 DOMDocumentFragment 中进行，然后用一次操作将元素片段放到 DOM 中，这样只触发一次 reflow。
  - 要在元素上做动画应该设置 `position: absolute | fixed`, 他们只会引发一个 repaint 而不是全部 reflow。
  - 通过 `scrollTo()` 进行原生滚动，性能显著，因为没有触发 reflow。
  - [Minimizing browser reflow](https://developers.google.com/speed/articles/reflow)、[js-repaint-perfs](http://mathieuancelin.github.io/js-repaint-perfs/)、[js-repaint-perfs](http://leeluolee.github.io/js-repaint-perfs/#)

dom 优化：

- 删除 dom 对象时，及时删除事件监听。
- js 对象引用操作 dom 对象后，需要设置为 null 或 delete 掉
- 尽量少访问 dom。be aware that although JavaScript engines continue to get faster, the next real bottleneck is the DOM.
- Don’t load from uninitialized or deleted elements.

js 优化：

Garbage collection 是内存管理机制，在 runtime 时自动运行、不受 js 控制。
如果某个变量引用是对对象的最后一个引用，那么垃圾回收会自动执行。
全局变量不会被垃圾回收，除非页面刷新、跳转或关闭。
函数作用域里的变量，在函数执行完毕、函数退出、没有引用时会被清理掉。
本来 Javascrip 引擎能检测正在执行中的 “热” 对象并优化它、让它执行更快速；但 delete 操作会「严重改变」对象结构，导致引擎不能优化该对象。将不需要的对象属性设置为 null 也比 delete 操作好，但这也是不必要的。[基础和全面的总结](http://www.smashingmagazine.com/2012/11/05/writing-fast-memory-efficient-javascript/)

- Don’t write enormous functions, as they are more difficult to optimize.
- 避免在一个数组里存在不同数据类型 (e.g. numbers, strings, undefined or true/false)
- 使用 innerHTML 把一大块元素替换掉，因为销毁的元素比较多、绑定着事件，会导致 GC 压力大。再插入新元素，再重新绑定事件。整体性能耗费比较大。
- call 比 apply 性能好！[参考](http://jsperf.com/apply-vs-call-vs-invoke)（angular1.0.6：2848行；backbone1.0.0：200行）
- `eval()`、`window.eval`、`new Function` 第一个不会被 GC 回收，后两个可以被 GC 回收。每次使用他们时都会调用脚本引擎将源代码转换成可执行代码；因此尽量避免使用。
- [JavaScript 启动性能瓶颈分析与解决方案](https://mp.weixin.qq.com/s?__biz=MzUxMzcxMzE5Ng==&mid=2247485658&amp;idx=1&amp;sn=a95acc8770470c50c2cd8d85a5b82e75&source=41#wechat_redirect)、[Memory Analysis 101](https://developer.chrome.com/devtools/docs/memory-analysis-101)

------

## H5

- [在做 iOS 和 Android 的 HTML5 开发时，你都掉到过哪些坑里？](https://www.zhihu.com/question/34556725)
- [intersectionobserver](https://developers.google.com/web/updates/2016/04/intersectionobserver)
- [`passive: false`](https://github.com/react-component/m-pull-to-refresh/commit/96474e3a6f9af544b9ad87fe4b7211b274ad1027)

### PWA / amp / Service Worker

移动 web 体验不太好，开发速度快、一般用来给 app 引流拉新用户，而 native app 体验好、开发速度慢，用来保活。
希望用 pwa + amp 来提升 webapp 体验。[渐进增强的 Web 体验（Progressive Web AMP）](https://zhuanlan.zhihu.com/p/24749809)，[ppt1](https://gw.alipayobjects.com/mdn/security_c/afts/img/A*ggnRRYNZjacAAAAAAAAAAABjARQnAQ)、[ppt2](https://gw.alipayobjects.com/mdn/security_content/afts/img/A*OIPXTaVg9kkAAAAAAAAAAABjARQnAQ)、[ppt3](https://gw.alipayobjects.com/mdn/security_c/afts/img/A*lghFTIKjO-sAAAAAAAAAAABjARQnAQ)、[ppt4](https://gw.alipayobjects.com/mdn/security_c/afts/img/A*bCcKSpjP6WAAAAAAAAAAAABjARQnAQ)。

- [amp](https://www.ampproject.org/)
- [How AMP achieves its speed - Google I/O 2016](https://www.youtube.com/watch?v=cfekj564rs0)
- [pwa](https://developers.google.com/web/progressive-web-apps/)
- [pwabuilder](http://www.pwabuilder.com/)

- [ServiceWorker](https://developer.mozilla.org/zh-CN/docs/Web/API/ServiceWorker)、
[Cache](https://developer.mozilla.org/en-US/docs/Web/API/Cache)
- [chrome://serviceworker-internals/](chrome://serviceworker-internals/) / [chrome://inspect/#service-workers](chrome://inspect/#service-workers)

- Service Worker 需要运行于 HTTPS 或本地 localhost 环境，是继 Web Worker 后又一个新的线程。来实现离线页面功能。
- Service Worker 是独立于页面的一个运行环境，它在页面关闭后仍可以运行。Web Worker 在页面关闭后不再运行。
- Service Worder 在安装（install）和激活(activate)后，关闭网络再次打开页面，资源的获取途径是“from ServiceWorker”

### Touch 应用

- 手势 & 模拟 scroll & list & pullToRefresh & pullToLoadMore
  - https://github.com/Lucifier129/pull-element
  - https://github.com/react-component/m-select-list

- https://github.com/react-component/m-picker/issues/43
- 原生实现的 framework7 picker https://github.com/framework7io/Framework7/blob/9f3589b2a2dc9d2119d41887a31309c8e811ec27/src/js/framework7/picker.js
- 基于 angular 的 ionic picker  https://github.com/ionic-team/ionic/blob/1573043f4e31cabe1bed6bb0f4b171a8575d360d/src/components/picker/picker-column.ts
- 基于 zepto 的 weui picker https://github.com/Tencent/weui.js/blob/81deb5c1c3da3e7d4d5d124d4c5da100171b8408/src/picker/picker.js
- 基于 react 的 weui picker https://github.com/weui/react-weui/blob/f8b12cd6f383b3e07c64442623839376384e33d0/src/components/picker/picker.js
- 基于 vue 的 饿了么 picker https://github.com/ElemeFE/mint-ui/blob/28abcb96cd6f85fae0863b36ef8a24cacf7f721e/packages/picker/src/picker.vue 
后三个压缩后体积都在 10k 左右，并且源码比较清晰无复杂依赖，没有多余代码。

### Touch 事件兼容问题

- 在 Android 上 Touchmove 只触发一次，解决：阻止默认事件，在start或move时，执行一次 e.preventDefault()
- 在 Android 上 页面滚动时，PageX/Y 并不包含滚动，需附加 scrollLeft/Top 修正
- 在 Android 上 在 a 标签上，move后不触发 touchend 事件，a 标签的 href 属性从`javascript:void(0)`改为`javascript:;`

### Touch事件穿透问题 (Ghost Clicks)

click事件在手机浏览器中的触发顺序：touchstart -> touchmove -> touchend -> click

浏览器在 touchend 之后会等待约 300ms 判断用户不是双击（double tap）行为，则触发 click 事件。
通过设置 meta 标签，禁止页面缩放，新浏览器不再需要等待 300ms [ref](https://webkit.org/blog/5610/more-responsive-tapping-on-ios/)。

如果绑定 touch 事件的 dom 元素在被点击触发后会隐藏、css3 transform 移走、requestAnimationFrame 移走等，而“隐藏、移走”后，它底下同一位置正好有一个 dom 元素绑定了 click 事件、或者有浏览器认为可以被点击有交互反应的 dom 元素（如 input 被点击有交互反应是获得焦点并弹起虚拟键盘），则会出现 **“点透”** 现象。

touch 事件在手机浏览器中的穿透问题，并不是由冒泡引起的，而是由于 click 事件延迟触发导致，所以通过阻止事件冒泡的方式解决穿透问题是不可行的。（iOS 系统通过在 touchend 事件里设置`e.preventDefault()` 阻止浏览器默认事件可以解决，Android 不可行）

最好使用 Fastclick 处理 click 事件，能同时解决 300ms 延迟和点击穿透问题（[Fastclick如何解决穿透事件](http://www.cnblogs.com/yexiaochai/p/3442220.html)）。

> Fastclick 通过在 touchend 触发时，自己创建一个 click 事件并手动触发，替代了用户的 click 事件。

### 屏幕尺寸

> mm(毫米)=?px(像素) : 两者没有转换关系，一个是绝对量，一个是相对量。比如15吋的显示器，你可以设置成 1024*768 像素，也可以设置成 1280*960 像素，可以有很多种。
> 像素就是CCD/CMOS上光电感应元件的数量，也即把影像放大数倍看到的小方点。作为图像的一种尺寸，只存在于电脑中，如同RGB色彩模式一样只存在于电脑中。
> 像素是相对于显示器“屏幕分辨率”而言的，譬如，WONDOWS的用户所使用的分辨率一般是 96像素/英寸。而MAC的用户所使用的分辨率一般是 72像素/英寸。
> 屏幕分辨率是指屏幕显示的分辨率，显示分辨率就是屏幕上显示的像素个数，分辨率160×128的意思是水平方向含有像素数为160个，垂直方向像素数128个。屏幕尺寸一样的情况下，分辨率越高，显示效果就越精细和细腻。
> 影像分辨率单位 PPI(Pixel per Inch)，打印(打印机输出)分辨率单位是 DPI(dot per inch). 人眼能分辨出的最大分辨率是300dpi，超过这个分辨率，人的眼睛是无法看出差别的，也就是说 300dpi 和 600dpi 在人眼看来是没有差别的，所以现在的冲印设备最大的设计输出分辨率，就是300dpi。
> 显示器出厂时一般不标出表征显示器分辨率的 DPI 值，只给出点距，我们根据公式即可算出显示器的分辨率。

- iPhone 4/4s : 屏宽320. (物理像素 640 * 960. 2x. 对角线 3.5-inch. PPI 326)
- iPhone 5/5s/5c : 屏宽320. (物理像素 640 * 1136. 2x. 对角线 4-inch)
- iPhone 6/6s/7 : 标准模式屏宽375，放大模式屏宽320. (物理像素 750 * 1334. 2x. 对角线 4.7-inch. PPI 326)
- iPhone 6/6s/7 Plus : 标准模式屏宽414，放大模式屏宽375. (物理像素 1080 * 1920. 3x. 对角线 5.5-inch. PPI 401)

```js
console.log(window.devicePixelRatio) // retina 屏 = 2 (1px = 2 物理像素) 6plus = 3
// 物理像素 / 逻辑像素 = devicePixelRatio
console.log(window.innerWidth) // device-width
console.log(document.documentElement.clientWidth) // viewport width
console.log(Math.sqrt(Math.pow(640, 2) + Math.pow(960, 2)) / 3.5) // iphone 4 ppi
```

- [屏幕尺寸，分辨率，像素，PPI之间到底什么关系？](https://www.jianshu.com/p/c3387bcc4f6e)
  - 在同一个设备上，它的像素个数是固定的，这是厂商在出厂时就设置好了的。只有不同的设备之间，才有像素大小的区别。
- [Physical Pixels / Logical Pixels](https://developer.appway.com/screen/ShowSingleRecipe/selectedRecipeId/1429057950522)
  - [Are pixels in Photoshop logical or physical?](https://graphicdesign.stackexchange.com/questions/81055/are-pixels-in-photoshop-logical-or-physical/81083)
- [「像素」「渲染像素」以及「物理像素」](http://www.zhihu.com/question/27261444/answer/35898885)
- [css 单位标准](https://www.w3.org/TR/css3-values/#absolute-lengths)
- [Android 设备单位转换](https://pixplicity.com/dp-px-converter/)
- [Android 设备单位](https://stackoverflow.com/questions/2025282/what-is-the-difference-between-px-dip-dp-and-sp-on-android)
- [iOS 设备尺寸](http://iosres.com/)

大部分移动设备默认的 viewport 都是 980px (layout viewport) 大于可视宽度(visual viewport)，多数情况下要大于 device-width(即 ideal viewport width 理想宽度) ,我们一般都要在移动端重置 viewport，让`width=device-width`, 使 layout viewport 变成理想宽度，这样可以做到按页面宽度 100% 充满屏幕，水平不出现滚动条。

高清方案 / 边线:

> [antd-mobile](https://github.com/ant-design/ant-design-mobile/issues/683#issuecomment-270117203)
> [anima-hd](http://gitlab.xx-inc.com/animajs/anima-hd)

- 为了便于计算, 通常让`1px == 0.01rem`即按 100 倍换算, 设计师按宽度 750px (iPhone 6 物理宽度, 2 * 理想宽度, [why?](https://www.zhihu.com/question/25308946/answer/32240185)) 做设计（适配到其他设备比例偏差不会太大），前端也按这个写 css 尺寸。那么：
  - dpr=1 `<html style="font-size: 50px">`, 设备: windows 电脑, mac (mar pro dpr为2).
  - dpr=2 `<html style="font-size: 100px">`, 设备: iPhone 4~6, Android.
  - dpr=2~4 `<html style="font-size: 100~200px">`, 设备: iPhone plus, Android Nexus 6P 等.
- 总结：
  - 根据不同设备dpr、去改变 html 元素上的 font-size 值、用 rem 能方便实现“元素尺寸等比缩放”效果。
    - 缺点：依赖的第三方组件，js内联px高度设置，iframe 等都需要适配。
  - 根据不同设备dpr、缩小 viewport scale 设置、自然支持 1px 物理像素的“细腻边线”效果。
    - 缺点：地图使用 canvas 绘制，而 canvas 的本质是位图，缩放后会糊掉。
  - 对于“横屏”或“大屏”设备、需要支持显示更多内容，适配规则：文字流式，控件弹性，图片等比缩放。
    - 控件弹性指的是，navigation、cell、bar等适配过程中垂直方向上高度不变；水平方向宽度变化时，通过调整元素间距或元素右对齐的方式实现自适应。这样屏幕越大，在垂直方向上可以显示更多内容，发挥大屏幕的优势。
    - 具体做法：不能全用 rem, 需要不变的地方用 px 代替 rem 。
- Android 上小于 1px 的边线、会变为 0px 而不能显示， iOS8 之后支持 0.5px 宽度。
  - 在代码里把`1px`改写成`1PX`, 使用`postcss-pxtorem`工具时, `1PX`的写法能避免被转为`0.01rem`, 并且`1PX`是能正常被浏览器渲染的(不区分大小写)。
  - [rem 产生的小数像素问题](http://taobaofed.org/blog/2015/11/04/mobile-rem-problem/)
- [Retina屏的移动设备如何实现真正1px的线？](http://jinlong.github.io/2015/05/24/css-retina-hairlines/)
- [1px 边线方案总结](https://www.w3cplus.com/css/fix-1px-for-retina.html)
  - ref: <https://ariya.io/2011/08/mobile-web-logical-pixel-vs-physical-pixel>

### 其他

页面横向能拖动问题：注意哪里设置了 width 之和为 100% ，但没设置`box-sizing: border-box;`

使用 <https://github.com/kisenka/svg-sprite-loader> 做 svg icon 图片部分 svg 渲染不出来：

- <https://github.com/kisenka/svg-sprite-loader/issues/53> 去掉 svg file 里的 mask
- 或者 改变默认样式设置 <https://github.com/kisenka/svg-sprite-loader/issues/59> `visibility:hidden`改为`display:none`

开启 Charles 代理，需要把其他代理软件关掉、像 ShadowSocks 要关掉、浏览器也不能有代理插件如 switchyomega 开着.
<https://github.com/ant-design/ant-design-mobile/issues/614>

```html
<!-- label 兼容性问题 -->
<label><input type="checkbox" />点击我 input 能被选中</label>
<label><input type="checkbox" /><span>点击我 input 不能被选中，因为有 span 包括</span></label>
此问题出现在包括 iOS 10 在内的大多数手机系统里；另外部分手机会出现点击选中延迟感严重的问题
```

```css
/* transform 闪动问题：*/
-webkit-backface-visibility : hidden;
-webkit-transform-style : preserve-3d;
-webkit-transform : translate3d(0,0,0)；
```

------

## node

[Node.js multithreading](https://blog.logrocket.com/node-js-multithreading-what-are-worker-threads-and-why-do-they-matter-48ab102f8b10)

[egg 早期架构图](https://gw.alipayobjects.com/mdn/security_content/afts/img/A*M3XeTKo_eAUAAAAAAAAAAABjATonAQ/original)

node module version example:
`1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta < 1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0`

```sh
npm help install  # 地址：https://docs.npmjs.com/cli/install

npm install tnpm -g --registry="http://registry.npm.xx.com" # 使用 cnpm 加速

npm uninstall / rm <pkg> [-g | -S|--save| -D|--save-dev ]

npm root/prefix [-g]  # 全局安装包位置
ls `npm root -g`  # 列出全局安装的模块列表

npm view <pkg> version(s)  # 查看模块的版本
npm info <pkg>  # 查看模块的详细信息
npm ls [-g]  # 查看当前安装模块的版本
npm ls -g --depth=0

npm repo / bugs / docs [<pkgname>]  # 浏览器自动打开提交 repo / bug / docs 的地址
npm bin [-g]  # 可执行文件位置

npm owner add <user> [<@scope>/]<pkg>
npm owner ls [<@scope>/]<pkg>

npm dist-tag ls [<pkg>]  # 查看 pkg 的发布版本
npm dist-tag add <pkg>@<version>  # 指定某个版本作为 dist 版本，默认安装

# npm link
cd ~/projects/proj  # go into the dir of your main project
npm i
npm link ../tool     # link the dir of your dependency
## 注意:
## tool 项目脚本里 避免有依赖全局的命令出现 如 execSync('rimraf dist') 这样会 link 报错
## tool 项目的依赖在 link 时会自动被安装，不用手动运行 npm i 命令

node hello.js &  # 后台运行程序
ps -ef | grep node  # 找到进程对应的ID
kill 3747(进程id)  # 杀掉后台进程

# 自动安装某 npm 包的 shell 命令：
node -e "$(curl -fsSL https://a.alipayobjects.com/u/localhost/js/201406/2u6LQfOLhF.js)"
```

peerDependencies:
[npm2-npm3](https://codingwithspike.wordpress.com/2016/01/21/dealing-with-the-deprecation-of-peerdependencies-in-npm-3/)

### node 适合场景：

- 创业公司很合适，尤其当创始人之一是熟悉前端的同学的话，用Node实现Web系统很合适。
- 重页面交互、轻业务逻辑的系统也适合Node来开发。

### 原理

In order to max out a multi-core server, people often start multiple node.js instances on a single server. That will work fine, but the node.js instances will be independent, and sharing data between them is not possible in plain JavaScript.

And because a node.js instance is single-threaded, it is also important that code written for node.js is non-blocking. Code that blocks while waiting for some I/O operation would block the only available CPU. Using non-blocking I/O operations allows node.js to queue the operation, and execute other code in the meantime, allowing overall progress. This also makes it look like it would be executing multiple actions in parallel, while it is actually executing them sequentially.

### node 核心库

- node 全局对象：global、process、buffer等
- socket 和 stream 模块
- EventEmitter 对象及事件
- [The Basics of Node.js Streams](http://www.sitepoint.com/basics-node-js-streams/)

### what is #!/usr/bin/env node

It's the unix way to say what interpreter a script should run with: "/usr/bin/env" looks up its next argument in the path and runs it -- so it works whether or not node is in /usr/local/bin or /usr/bin or some obscure place that's in the path, rather than directly hard-coding the path to node, which presumably varies more than the path to env.

When you shebang (#!) /usr/bin/env node, you are saying "look for a program called node on my PATH". If doing node -v works, as @Ryan says, the shebang should work fine. Any chance you have a shell alias or shell function named node? That could be giving you the illusion that your PATH is correct even when it is not. But essentially, just make sure the directory where the node binary lives (the bin directory under your node install) is on your PATH environment variable, and things really should work at that point.

[让你的程序更可读 - node / java AOP](https://github.com/frontend9/fe9-library/issues/36)

------

## css & html

- querySelector api 不能传入「纯数字」的 id/class 选择器？
- [不能根据子元素 class 改变父元素 class](http://stackoverflow.com/questions/1014861/is-there-a-css-parent-selector)
- id、class 选择器被标签选择器限制，都是多余的。
- css 浏览器私有属性在前面， W3C标准属性在后面，Hack属性在更后面。
- z-index 属性仅在节点的 position 属性为 relative, absolute 或者 fixed 时生效.
- Do not use quotation marks in URI values (url()).
- css2.1 的 counter-increment，详见[使用](http://onwebdev.blogspot.com/2012/02/css-counters-tutorial.html)。  

All elements that are `position: absolute;` are automatically treated as `display: block`, since that's the only logical display mode for absolute positioning.

- [html5 和 css3 动画排列人物头像演示](http://www.w2bc.com/Article/11916)
- [Google HTML/CSS Style Guide](http://google-styleguide.googlecode.com/svn/trunk/htmlcssguide.xml)
- [CSS Compatibility and IE](https://msdn.microsoft.com/library/cc351024(VS.85).aspx)

- [BEM命名方式](http://csswizardry.com/2013/01/mindbemding-getting-your-head-round-bem-syntax/)
- [css命名、组织方式](http://benfrain.com/enduring-css-writing-style-sheets-rapidly-changing-long-lived-projects/)
- [值得参考的css理论：OOCSS、SMACSS与BEM](http://segmentfault.com/blog/yardtea/1190000000704006)
- css 与 js 完全分离，用 J_ 或 j- 做js钩子

- [如何提升 CSS 选择器性能](http://www.jianshu.com/p/268c7f3dd7a6)
- [理解css时间函数](http://www.smashingmagazine.com/2014/04/15/understanding-css-timing-functions/)
  - [贝塞尔曲线](http://cubic-bezier.com/#.42,0,.28,1.03)
- [css浮动](http://paranimage.com/css-float-attribute/)

- [Font-Awesome](http://fortawesome.github.io/Font-Awesome/)
- [livicons](http://livicons.com/)

[`<head>`里能放什么？](https://github.com/joshbuchea/HEAD)

- 编码和字符集的区别：gbk、utf-8 都是字符集。 http 数据传输时的编码和界面显示使用的的字符集的区别。
- `<meta charset="utf-8" />`要置于`<title></title>`之前，能使得浏览器先获得编码设置，来正确解析页面中文本内容。（不然，老IE浏览器可能会有问题）
- [URL 编码，为什么要编码？](http://anjia.github.io/2015/04/15/jsURIEncode/)
- 浏览器在自动选择编码方式的时候不会优先根据 html 源码中的所展示的`<meta charset="utf-8" />`代码来决定选择什么编码方式，而是优先根据“响应标头-response header”中的键为“Content-Type”的值来自动选择判断。（老IE浏览器相反）

### html 标签使用注意点

- [div 和 span 都是作为容器元素](http://www.w3.org/wiki/Generic_containers_-_the_div_and_span_elements)
- p 标签里不能有块(block)标签，否则`<p>`标签会提前结束导致解析错误，也会连环导致其他标签解析错误
- `<select>` is inline by default
- span 标签里可以放几乎任何标签？
- a 标签带 href 并不为空，按 enter 键都会触发其上的 click 事件，否则不会触发！
- img script 的 src、css 的 href 都不能为空，否则会有个指向本页面的请求
- [DOM 的 attribute 和 property](http://www.noahlu.com/blog/javascript-note/dom-attribute-property/)
- p 标签不能嵌套块级元素，button 里面不要嵌套 a 标签。
- ul 和 ol 的子元素不能是别的元素只能是 li，不能是别的比如 div 等（ie6会有问题）。
- dt标签里面不能嵌套块级元素，只能嵌套内联元素，dd可以。

### 键盘、可访问性

- [键盘聚焦并可点击](http://www.456bereastreet.com/archive/201302/making_elements_keyboard_focusable_and_clickable/)
- [aria](http://www.paciellogroup.com/blog/2010/04/html5-and-the-myth-of-wai-aria-redundance/)
- [WAI-ARIA](http://www.w3.org/TR/wai-aria/usage#managingfocus)
- [aria-hidden and role="presentation"](http://asurkov.blogspot.com/2012/02/aria-hidden-and-rolepresentation.html)

------

## 质量

- <https://codecov.io/> 覆盖率分析对比工具
  - 支持所有语言，对 GitHub commit 的覆盖率做记录、前后对比。
  - antd 等开源项目的选择。
- 覆盖率类别：<https://blog.rsuitejs.com/2017/08/20/test-coverage/>
  - Statements 与 Lines 的区别：一行可能有多个语句
- 百分百测试覆盖率真的有意义吗？ <https://www.zhihu.com/question/29528349>
  - 各种 corner cases(比如除0、 IO error handling) 很难做到 100% 覆盖。
  - 覆盖率数据只能代表你测试过哪些代码，不能代表你是否测试好这些代码。
  - 不能盲目追求代码覆盖率，而应该想办法设计更多更好的案例，哪怕多设计出来的案例对覆盖率一点影响也没有。
- JS 覆盖率工具 <https://istanbul.js.org/>

## Web Components

- [webcomponents.org](http://webcomponents.org/)
- [webcomponents-the-right-way](https://github.com/mateusortiz/webcomponents-the-right-way)
- [Why Web Components Are Ready For Production](http://developer.telerik.com/featured/web-components-ready-production/)

- [Shadow DOM 101](http://www.html5rocks.com/en/tutorials/webcomponents/shadowdom/)
- [template](http://www.html5rocks.com/en/tutorials/webcomponents/template/)
- [custom elements](http://www.html5rocks.com/en/tutorials/webcomponents/customelements/)

- [polymer](https://www.polymer-project.org/)
- [谈谈Google Polymer以及Web UI框架的未来](http://www.csdn.net/article/2013-05-27/2815450-google-polymer)
- [observe-js](https://github.com/Polymer/observe-js)
- [TemplateBinding](https://github.com/Polymer/TemplateBinding)
- [handlebars-vs-polymer-mdv](http://jsperf.com/handlebars-vs-polymer-mdv/14)

## 组件设计

- [javascript组件化](http://purplebamboo.github.io/2015/03/16/javascript-component/)
  - 设计一个组件类（如 `function TreeView(){}` ）
  - 设置组件类的配置项或属性（`function TreeView(config){ this.cfg = extend({}, config); }`）
    - 组件的属性，只能通过方法来访问。组件的属性 value change 后组件自动映射变化。
  - 组件类上附加组件方法（`TreeView.prototype.xx = function (){ }`）
  - 为组件添加自定义事件
    - mixin 进来带有 on / off / fire 等方法的事件系统，为组件级别添加事件，屏蔽底层的 dom 事件，方便使用。
  - 抽出 Widget 抽象类，作用是为 ui 组件提供统一的接口名，统一生命周期管理。
  - 组件使用方式：new出组件实例使用

- [Backbone View 之间通信的三种方式](http://www.geekplux.com/2015/07/04/communicating-between-views-in-backbone.html)
- [如何实现一个 mvvm 组件](http://shepherdwind.com/2014/05/17/how-to-reliaze-mvvm--bidi/)

### 设计原则：

- 职责清晰、单一职责
  - 组件的每个模块，分别该承担哪些功能？
  - 多个组件/模块协同完成一件事情，而不是一个组件替其他组件完成本该它自己完成的事情
- 开放与封闭
  - 属性配置等API对外开放；组件内部dom及状态的更改、对外封闭
- 高内聚、低耦合
  - 组件内部通过callback方式直接调用，组件与组件之间通过发布订阅的模式通信
- 避免信息冗余
  - 例如：一个东西能被另一个推导出来，就只使用一个
- API 尽量和已知概念保持一致
  - API 命名：比如 聚焦 常用命名是 focusable 而不是 canFocus 等自己臆想的名字、还有如 onDeselect 等规范名字。
  - API 的功能要单一并表意：比如 active 表示活动状态、但不能代替表示 selected 选中状态。

### Tree 组件

实现功能：节点展开收起、单选/多选、checkbox、异步加载、右键菜单、节点增删改查、节点拖动。

- 根据用户设置的 checkedKeys（e.g.['key1', 'key2']）遍历所有节点，设置各级节点的「选中/半选/不选」状态。
  - 某节点设置 checked，其子节点都要checked。
  - 再根据兄弟节点的 check 状态，循环设置父级节点的check状态。
- 根据用户设置的 expandedKeys（e.g.['key1', 'key2']）遍历节点，设置节点的 expand 状态。
  - 子节点设置 expand，循环设置父节点也要 expand。
  - 但点击父节点，子节点 expand 状态不能变。

### 拖动

- 在 touchstart 中记录起始位置，并开始监听 touchmove 和 touchend
- 在 touchmove 中计算当前位置和起始位置之间的 offset，并进行拖拽操作
- 在 touchend 中取消监听 touchmove 和 touchstart，并进行释放操作

### Form 及验证

- form 要支持“只使用键盘”完成表单填写并按 enter 键要能触发表单提交，使用 type="submit"
- 声明式的「验证规则、错误提示」设置
- 动态设定错误提示（如 Ajax 返回后根据错误码手动设置错误提示）
- 自定义错误触发条件
  - 如 required 验证对于文本框默认为空时触发，对于“多选框”验证时，需要验证选择后的数据数组长度是否为零时触发，与文本框不同。
- 参考 ng 里针对 `ng-model="xx"` 绑定的 xx 数据进行验证，校验结果自动反馈到相应 dom 上。

验证方式，以 js 对象的验证为主，把 dom 上的值附加进来，如[validate.js](https://github.com/ansman/validate.js)

### Tabs - tab

- API：selected | on-select | on-deselect
- tab 切换后，前一个页面的 Ajax 请求还没完成，要不要 abort 掉？
- <https://github.com/ant-design/ant-design-mobile/issues/1287>

### Modal

- 弹出框允许放到某个内层元素里，或者 body 元素下
- 在 body 下时，都 append 到 body 末尾闭合处，而不是在 body 标签开始处
- 背景层 backdrop/mask，有的直接放在 body 下和 modal 框平级，有的放到 modal-container 里边(感觉更好)

### 其他组件

> [元素定位](https://github.com/HubSpot/tether)

- Grid 组件与 Table 组件区别
  - Grid（[datagrid](https://github.com/zippyui/react-datagrid)），使用 div 不用 table/tr/td，支持可变列数、筛选、排序、列宽度拖动改变、单选多选、分页、行列单元格自定义样式。
  - Table 组件，使用 table / tr / td 用于简单表格展示。
- Notify / Message 类的组件应该区分成两类。
  - 一类：点击某个按钮，或操作成功失败时，页面某个位置出现的弹出框。（例如顶部或右上角弹出的通知）
  - 二类：页面最顶部固定的一行横通知条。（例如系统维护通知）
- 弹窗类、展开收起类组件，处于页面底部时，展开后，不能全部出现在可视区域，需要改变滚动条位置。
- DatePicker / TimePicker 注意能合到一起使用的情况（最好看起来是无缝整合），也要能分开使用。
  - TimePicker 搜索当天，从00:00:00到23:59:59；限定可以选择的时间范围，最小时间、最大时间(例如最小时间是now，最大时间如果不设置、那默认是多少?)
  - DatePicker / TimePicker 共用一个时间点时，之间的影响（例如datepicker选完日期，可能会重置时间为 00:00，影响 TimePicker 怎么处理?）
- Select 组件：支持 Infinite scroll
- Modal 等弹窗类组件，必须有`destroy`方法。应用场景：普通按钮，列表
- Pagination 组件，如图 ![page](https://t.alipayobjects.com/images/rmsweb/T1OIlhXmVcXXXXXXXX.png)
  如果数据总数50万+时，每页显示5个页码，下拉框就会有10万条目，导致页面dom数过大，浏览器崩溃。
- 图表组件，给出`destroy`方法，并测试是否有内存泄露(多操作或刷新几次页面是否卡顿)。
  - 图表纵坐标根据数据自动生成，要满足业务对生成数据的特殊要求，如：不能有负值；只能是整数值(不能是小数)
- Upload 组件，添加了不允许上传的文件类型，给出错误提示。
- Select / tags-input 组件
  - 特殊需求：在 [tags input select](http://react-component.github.io/select/examples/tags.html) 里，想直接输入一串如 `name1,name2,name3,name4,nam5,....` 这样比较长的内容（预先准备好的人员列表），组件自动根据分隔符(例如这里的逗号)，split 出来，然后分别验证这些条目是否合法（如果分别发Ajax将会很多、不可行），再转换为一个个 tag。 这种需求一般是单独做一个「导入」文件或组的功能来实现，但放到 tags-input 组件或 select 组件里，感觉也有一定合理性。 在 select2 的 [Automatic tokenization](https://select2.github.io/examples.html#tokenizer) example 里输入 `red,blue,green,`  这串特定分割的字符串，会自动根据逗号 split 出三个 tag 出来。select2 这个还能输入更多自动保存到选择list里，也不涉及到发Ajax操作。

注意：一些命令式 API 比如 `Popup.show(<Component />)` 的使用限制：
假如 A 组件的 click 方法里 调用了 `Popup.show()` ，最后会需要使用类似（此处故意加 res）
`const res = ReactDOM.render(<Component />， new_Mount_Node)`，
这会在新的 new_Mount_Node 根节点渲染 Component 组件，这与调用者 A 组件 所在的 mount 根节点 不是同一个。
如果 A 组件所在组件树上有 新的数据，要更新 Component ，此时需要重新调用 `Popup.show()` 方法、即需要重新执行上述 `ReactDOM.render` 代码来进行更新。
但是 `Popup.show()` 方法调用时会有入场动画等，更新数据时不再需要显示动画，可以考虑加上 `Popup.update()` 方法，
也需要重新调用 ReactDOM.render ，如果动画是做在 Component 组件里边，同样还会有动画，无法解决。
那是否能通过 ReactDOM.render 的返回值 res 来获取到 Component 手动调用什么方法进行更新呢？没方法能做到。
最终解决办法：hack 方式、在更新数据时去掉动画。
-- 总结，对于这种命令式 API , 最好是只传入简单字符串，如果传入复杂组件，组件自己维护状态、跟调用者的状态关系尽量少。

## 前端 MVC

MVC 是一个流行的软件架构。可以从 Ruby on Rails 获得许多有关 MVC 的基本设计原则，将其引入并支持 node 的 MVC 设计。Express 已经采用了路由的概念（Rails 的基本原则），还需要分离的模型：视图和控制器。接下来，创建 controllers、model、views 目录等，将现有的每个路由的方法调用转换为单独的函数然后导出，等操作。MVC 架构使得代码看起来干净又简单，并且扩展性更好。

- Model
  - model 里存放的是「需要持久化的数据」(DO, domain object)，而不是页面显示用的临时数据（VO, view object / ui state）。
  - model 里可以包含对Ajax请求参数的组装、处理；如果返回数据也需要统一处理，可以写相应的统一处理函数？
  - 公共 model 抽取出来放一个地方；不同页面特有的 model 邻近相应 view 放置
  - model 是否是 singleton 的？使用时需不需要 new ？
- View
  - 页面全部组件化（参考react组件化思路）
    - 抽象出组件的方式尽量简单（react比angular组件简单）
    - 需要复用的代码片段、抽象成组件（哪怕仅是两三行代码，但需要到处复用）-- 小组件
- controller
  - 内容应尽量少，在 controller 里设置页面显示用的运行时数据（VO, view object / ui state），持久化的数据从model里获取。
  - Any time you need to store information only for the lifetime of this application run, you should store it on a controller.

### model 不同的设计思路：

- [Backbone.Model](http://backbonejs.org/#Model)
- [ember-models](http://guides.emberjs.com/v1.10.0/models/)、[ember-data-model-maker](http://andycrum.github.io/ember-data-model-maker/)

ember-data 处理方式：

- `DS.Model` 用来创建数据模型。定义了需要呈现给用户的数据的属性和行为。
  - 不同模型之间会有关联关系：一对一，一对多，多对多。与后台数据库模型类似。[原文](http://guides.emberjs.com/v1.10.0/models/defining-models/#toc_defining-relationships)、[翻译](https://m.oschina.net/blog/518608)
  - 模型本身没有任何数据；模型只定义了其实例所具有的属性和行为，而这些实例被称为记录。
  - 记录是模型的实例，包含了从服务器端加载而来的数据。应用本身也可以创建新的记录，以及将新记录保存到服务器端。
- `DS.Store` 中心数据仓库，是应用的所有数据的缓存。一般整个应用只有一个 store 生成，负责创建/删除/查找/过滤/定位 `DS.Model` 的实例。
  - 注意，重申下 Model 只是数据的属性和行为，Model 的实例 record 包含具体的数据，由 store 创建存储管理。
- 利用不同的 Adapter 和不同服务端通信，如：HTTP、Websocket 等。

在 react.js 的 flux 等架构中，是不建议使用「fat model」的。[model使用](https://medium.com/swlh/the-case-for-flux-379b7d1982c6)

fat model, skinny controller. the model should do the heavy lifting are:

- Validation in the case of CRUD functionality and post methods.
- Type-conversions and data manipulation.
- Storing data in memory or in HTML5 databases to minimize server hits.

The server-side code mainly does model manipulation and notifications, and so having a fat model/thin controllers makes sense. The controller is essentially the router to the model.

### 业务场景

#### 文章下边的 “like” ：

- 有一个 “like” 按钮。
- 显示前十个喜欢此文章的用户。（对应一个 API）
- 单独一个模块显示喜欢此文章的全部用户，带有分页。（对应另一个 API）
- 点击 “like” 按钮，以上两个区域的数据改变。

这里对于点击了喜欢的用户，需要有个「model collection」，但是需要一个 model 或者是 两个 ？

> It would be nice if those two lists corresponded to the same model collection, but this means the same model collection needs to be fed from two different API responses. Turns out, 1:1 correspondence between API responses and model objects doesn’t scale!

## SPA

### SPA 实现原理

- 如果浏览器支持 history API，使用 pjax (pushState + Ajax)
  - 点击一个链接，通过 Ajax 获取页面部分区域数据（向服务器发送一个有PJAX标志(设置在header里)的请求，服务器返回一段相应的html片段）
  - 通过 pushState 修改 URL 和 document.title，并把服务器返回的htm片段插入页面。
  - Github上的文件/目录跳转加载，就是采用 pjax 的方式实现的。
- 如果浏览器不支持 history API，使用 hash 如 <http://example.com#word>
  - 浏览器会把不同的 hash 记录到历史记录中，但需要监听 hash 值的变化。
  - 对于支持 onhashchange 的浏览器，监听此事件；不支持的则要定时去判断hash的变化。

### spa 基础问题

- 切换路由后会把上个路由状态生成的html全部销毁掉，再切回来恢复不到原来的样子。
- 客户端渲染和服务端渲染，哪个快？
- Batching HTTP Requests to Improve Performance

## form相关：

### get、post 区别

- 获取数据用get，get速度快、有长度限制
  - get只能向服务器发送ASCII字符，这是W3C组织规定的，所以任何参数最后都要以ASCII码的形式传递，不能有中文字符。
  - get编码方式是根据当前网页采用选择的编码来编码。所以，当前网页如果是gbk编码，get的参数也会被编码为gbk，用`decodeURI()`或`decodeURIComponent()`(它们都是解utf-8编码的) 解码就会出现js异常抛错。
  - 对于要拼接到uri后面的中文参数进行encodeURIComponent或者encodeURI编码处理，因为encodeURIComponent或者encodeURI就是utf-8的编码方法，后端处理参数的解码方式一般也都是utf-8方式，这样不会出现后端获取中文乱码情况。
  - 浏览器发送数据给服务器时，会把数据进行浏览器编码成字节流

- 提交数据用 post，post 慢、理论上无长度限制(服务器端可能会规定最大长度)，post 相对安全

> 用 post 做查询，刷新浏览器会弹出 “是否重复提交数据” 的弹框。改用get来做。

### form 的 method、action、target、enctype

- method 默认值为get
- action 属性表示 向何处发送表单数据 (一般为url)。
  - 如果不设置、或为空，则提交到本页面
  - 如果get方式提交、action url中参数都会被丢弃；post则不会

- target 属性规定在何处打开 action URL
  - 值可为：_self(默认值) | _blank | _parent | _top | framename
  - 当设置为 隐藏的 iframe name 时，能实现假的 表单提交无刷新效果

- enctype 规定在发送表单数据之前如何对其进行编码
  - 设置：application/x-www-form-urlencoded (默认值)，按照`key1=val1&key2=val2`的方式进行编码，key 和 val 都进行了 URL 转码
  - 设置：multipart/form-data ，使用表单上传文件时，必须让 form 的 enctype 等于这个值
  - 设置：application/json ，发送消息为序列化后的 JSON 字符串

[FormData 配合 xhr2 能很方便的处理form表单！](https://developer.mozilla.org/zh-CN/docs/Web/Guide/Using_FormData_Objects)

### 上传文件

1. form 同步上传 (使浏览器不刷新的做法: form target 指向隐藏的 iframe, 服务端 action 返回`window.top.window['callback'](data)`)
2. XMLHttpRequest 2 支持真正异步上传, form enctype 属性为 multipart/form-data , 构造 FormData 对象.
3. 使用 fetch + FormData 上传文件时、不能设置 headers 的 Content-Type (或设置为 undefined)，浏览器会自动设置为合适值 (比如 Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryIn312MOjBWdkffIM)，参考<https://stackoverflow.com/a/39281156/2190503> 和<https://stanko.github.io/uploading-files-using-fetch-multipart-form-data/>
4. 用通常的 http://localhost:8000/ 访问服务端上传文件的接口时，会报出 跨域 错误，而用 127.0.0.1 或其他绑定的 host 都没问题，为什么？
5. 服务端需要设置“松散的 ctoken 检测”?

- [jquery file upload 后台收到 filename 中文乱码](http://blog.csdn.net/zhouyingge1104/article/details/38322403)
- [在文件对象上如何附加其他 input 的字段？](https://github.com/blueimp/jQuery-File-Upload/wiki/How-to-submit-additional-Form-Data#adding-additional-form-data-programmatically)
- base64 形式提交处理后图片，图片文件大小怎么计算？
- 上传前先压缩文件？以减少上传文件大小，怎么做？
  - 浏览器端被设计为发送简短http请求，浏览器端请求不用压缩，[见此](http://stackoverflow.com/questions/424917/why-cant-browser-send-gzip-request)。
  - 一种办法：客户端安装applet，并相应简单配置，[见此](http://www.radinks.com/upload/plus/compress.php)。
  - 图片上传前压缩[办法](http://blog-en.openalfa.com/javascript-client-side-compression-of-images/)。

### 下载

注意：Ajax不能下载文件。[解释](http://stackoverflow.com/questions/14682556/why-threre-is-no-way-to-download-file-using-ajax-request)。可以用form表单提交下载，或iframe方式下载。

点击需要下载文件的连接，后端处理：`Content-type: application/octet-stream`、`Content-Disposition: filename=\`

- [单纯使用js下载文件](http://stackoverflow.com/questions/3749231/download-file-using-javascript-jquery)
- [纯前端-生成文件并下载](http://www.alloyteam.com/2014/01/use-js-file-download/)

## 安全

[a 标签中 target="_blank" 的安全漏洞](https://www.tutorialdocs.com/article/html-opener-blank.html) 详细地解释了该漏洞的攻击方法和原理。并在文末给出了防范该漏洞的解决办法：给 a 标签增加 rel="noopener noreferrer nofollow"。

- jsonp请求也需要「防止csrf漏洞」，例如可以用jsonp获取通讯录列表
- cors跨域：http头可以伪造，所以跨域的时候记得带上sessionId做身份验证；防止允许跨域的站点被入侵，从而导致源站信息泄露；不要对Access–Control-Allow-Origin使用`*`

[csrf漏洞](http://www.cnblogs.com/hyddd/archive/2009/04/09/1432744.html)、[wiki](http://en.wikipedia.org/wiki/Cross-site_request_forgery)、[wiki中文](http://zh.wikipedia.org/wiki/%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0)
XSS 利用的是用户对指定网站的信任，CSRF 利用的是网站对用户网页浏览器的信任。

跨站请求攻击，简单地说，是攻击者通过一些技术手段欺骗用户的浏览器去访问一个自己曾经认证过的网站并执行一些操作（如发邮件，发消息，甚至财产操作如转帐和购买商品）。由于浏览器曾经认证过，所以被访问的网站会认为是真正的用户操作而去执行。这利用了web中用户身份验证的一个漏洞：简单的身份验证只能保证请求发自某个用户的浏览器，却不能保证请求本身是用户自愿发出的。

When CSRF protection is enabled, all non-GET requests to the Sails server must be accompanied by a special token, identified by either a header or a parameter in the query string or HTTP body.

为防止csrf漏洞，传统表单里默认有生成了随机token的隐藏input，同步提交表单时能自动提交上去，同步提交后刷新页面会再次更新token。

但使用Ajax异步提交时，提交时要从Cookie里(或页面上)获得token值（这里假设攻击者不能获得第三方的Cookie，但用户的Cookie很容易由于网站的XSS漏洞而被盗取），另外要考虑在提交后是否需要手动更新Cookie里(或页面上)的token。

> [ajax里如何更新csrf token](http://www.v2ex.com/t/82751) ，最后的一段评论提到：csrf-token的目的是，让攻击者不能伪造请求（如通过img发起的请求会带上cookie）。因此，csrf-token不需要每个请求都改变，只需要确保对于每个session不一致即可，同一个session内不变没有问题。

[csrf 详解](https://tech.meituan.com/fe_security_csrf.html)

[jQuery Ajax post提交的csrf token处理](https://gist.github.com/alanhamlett/6316427)  
[jQuery Ajax post提交的csrf token处理1](https://coderwall.com/p/cxwg_g)

```js
$.ajaxSetup({
  headers: { "X-CSRFToken": getCookie("csrftoken") }
});
// 注意：可能需要对Cookie做 encodeURIComponent 处理
```

## 跨域通信

[详细介绍](http://www.cnblogs.com/rainman/archive/2011/02/20/1959325.html)

- xhr1 无论是 get 或 post 都 **不能跨域**
- xhr2 有两方面的增强：通信进度通知，跨域通信。
  - 它使用[Cross-Origin Resource Sharing](https://developer.mozilla.org/en-US/docs/HTTP/Access_control_CORS#Simple_requests)，W3C制定的跨站资源分享标准。post前会产生一次 options 嗅探（称之为preflight，简单请求就不会出现）来确认有否跨域请求的权限；客户端 post 时会带上Origin 头指示来源网站，服务端响应时需带上 Access-Control-Allow-Origin 头与 Origin 的值匹配。
  - cors 实例，如下图（options嗅探）：
  - ![cors实例](https://t.alipayobjects.com/images/T1olFfXcpaXXXXXXXX.png)

- jsonp 跨域：JSONP 属于跨域 get，其之所以可行是利用了 script 标签的特性。
  - 实质是 script 的 src 里携带向服务器请求的 data，返回的 data 包裹在函数调用里，供数据处理函数使用
  - 只能传 4kByte 以下的数据？因为ie限制了url的长度为4k ？

- form + iframe (假无刷新)：通过 js 动态生成不可见表单和iframe，将表单的 target 设为 iframe 的 name 以此通过 iframe 做 post 提交。
  - 提交后由于跨域，无法直接读取响应内容。一般的做法是，iframe 内通过 js 改变自身 location 的 fragment，外部则监听iframe 的 onload 事件，读取 fragment 的内容。
  - iframe 的 src 改变时[事件侦听](http://stackoverflow.com/questions/2429045/iframe-src-change-event-detection)，`<iframe src="zz" onLoad="xx();"></iframe>`

- 设置 document.domain，来实现“跨子域”，但有[不好的地方](http://www.cnblogs.com/jkisjk/archive/2013/05/30/change_document_domain.html)

- flash 跨域：利用不可见的 swf 跨域 post 提交数据，需要部署 crossdomain.xml。若用户安装了flash，则以此实现跨域通信。响应数据量较大时优势明显

- [跨域iframe的高度自适应](http://www.cnblogs.com/snandy/p/3900016.html)
- 页面有使用 `window.opener.xx()`之类、因为opener可以为任何域，所以存在`跨域`错误。利用`try..catch`捕获

### 其他方法

- HTML5 postMessage
- document.domain + iframe 的设置
- window.name 实现的跨域数据传输
- 利用 iframe 和 location.hash，会导致历史记录的产生，且数据量有限，同时，因为 URL 的内容可视，既不好看也容易泄露信息。
- 用服务端代理？ 虽然算是最“正宗”的完整跨域方案，但太麻烦了点——首先得有代理，如果量大的话，代理的负担会很重，会导致“瓶颈”制约。

### postMessage 跨域详解

> ie8及以上浏览器都支持

#### otherWindow.postMessage(message, targetOrigin)

otherWindow: 对接收信息页面的window的引用。可以是页面中iframe的contentWindow属性；window.open的返回值；通过name或下标从window.frames取到的值。
message: 所要发送的数据，string类型。
targetOrigin: 用于限制otherWindow，“*”表示不作限制

#### 示例：

a.com/index.html中的代码：

```html
<iframe id="ifr" src="b.com/index.html"></iframe>
<script>
  var ifr = document.getElementById('ifr');
  var targetOrigin = 'http://b.com';  // 若写成'http://b.com/c/proxy.html'效果一样
                                      // 若写成'http://c.com'就不会执行postMessage了
  ifr.contentWindow.postMessage('I was there!', targetOrigin);
</script>
```

b.com/index.html中的代码：

```js
window.addEventListener('message', function(event){
  // 通过origin属性判断消息来源地址
  if (event.origin == 'http://a.com') {
    alert(event.data);    // 弹出"I was there!"
    alert(event.source);  // 对a.com、index.html中window对象的引用，但由于同源策略，这里event.source不可以访问window对象
  }
}, false);
```
