
# 算法
递归、尾递归，构造多叉树、二叉树，排序算法。

几种常见的JS递归算法 https://juejin.cn/post/6844904014207795214

js 算法 https://github.com/trekhleb/javascript-algorithms

[LeetCode](https://leetcode.com/)
[Google 历年笔试面试30题](http://ask.julyedu.com/question/447)

2009 POJ推荐50题 —— 参加06年BUPT ACM暑假集训前要求完成 列表中大约有70个题目。大家选做其中的50道，且每类题目有最低数量限制。 POJ == 北京大学ACM在线评测系统 http://acm.pku.edu.cn/JudgeOnline

## 基础知识点

数据结构：
- 逻辑结构与存储结构（顺序、链接）
- 线性结构（线性表）：栈、队列、串
- 非线性结构：数组、广义表、树、图

优先队列(priority queue) 是不同于先进先出队列的另一种队列。每次从队列中取出的是具有最高优先权的元素

二叉树结构可以用数组表示。
二叉树的基本性质、满二叉树与完全二叉树、二叉树的遍历（前序、中序、后序遍历）。

### 时间复杂度：

渐近时间复杂度的表示法T(n)=O(f(n))，这里的"O"是数学符号，它的严格定义是"若T(n)和f(n)是定义在正整数集合上的 两个函数，则T(n)=O(f(n))表示存在正的常数C和n0 ,使得当n≥n0时都满足0≤T(n)≤C*f(n)。"用容易理解的话说就是这两个函数当整型自变量n趋向于无穷大时，两者的比值是一个不等于0的常数。

按数量级递增排列，常见的时间复杂度有：常数阶O(1),对数阶O(log2n),线性阶O(n),线性对数阶O(nlog2n),平方阶O(n2)，立方阶O(n3),k次方阶O(nk), 指数阶O(2n) 。随着问题规模n的不断增大，上述时间复杂度不断增大，算法的执行效率越低。

Ο(1)表示基本语句的执行次数是一个常数，一般来说，只要算法中不存在循环语句，其时间复杂度就是Ο(1)。Ο(log2n)、Ο(n)、Ο(nlog2n)、Ο(n2)和Ο(n3)称为多项式时间，而Ο(2n)和Ο(n!)称为指数时间。计算机科学家普遍认为前者是有效算法，把这类问题称为P类问题，而把后者称为NP问题。

如果算法的执行时间不随着问题规模n的增加而增长，即使算法中有上千条语句，其执行时间也不过是一个较大的常数。此类算法的时间复杂度是O(1)。

### 迭代与递归

迭代用重复结构，而递归用选择结构。递归与迭代都涉及重复：迭代显式使用重复结构，而递归通过重复函数调用实现重复。

递归有许多缺点，它重复调用机制，因此重复函数调用的开销很大，将占用很长的处理器时间和大量的内存空间。每次递归调用都要生成函数的另一个副本(实际上只是函数变量的另一个副本)．从而消耗大量内存空间。迭代通常发生在函数内，因此没有重复调用函数和多余内存赋值的开销。

假使一个递归过程中本身包含了大量冗余的操作，并且这个过程又可以用迭代来达到相同的效果。这时，我们就一般用迭代来消解递归。尾递归算法和单向递归算法可用迭代算法来代替。斐波那契数列计算的递归改循环迭代所带来的速度大幅提升，是因为改掉了重复计算的毛病。

不需要消解的递归。如汉诺塔问题等。汉诺塔问题的递归算法中有两处递归调用，并且其中一处递归调用语句后还有其他语句，因此该递归算法不是尾递归或单向递归。要把这样的递归算法转化为非递归算法，并没有提高程序运行的速度，反而会使程序变得复杂难懂，这是不可取的。

### 排序

快排的算法就是把一排数整理后对半分整理后再对半分整理后再对半分。。。直到内容只有两个或者一个，那么这个子段就有序了。

n个数1次划分成2个，2次划分成4个，3次划分成8个。那么多少次才能将这n个数划分成两个或者1个序列呢？也就是2的多少次幂等于或者接近n，所以就有划分次数为log2(n)。因为每个划分段都要比较n次，所以一共比较次数是n*划分段数log2(n)

递归与分治策略
