<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8" />
</head>
<body>
<script>
  // 冒泡排序 时间复杂度 O(n²)
  function bubbleSort(arr) {
    let _count = 1;
    for (let i = arr.length - 1; i > 0; i--) {
      for (let j = 0; j < i; j++) {
        console.log('for _count', _count++);
        if (arr[j] > arr[j + 1]) {
          // 交换次数 最多 n(n-1)/2
          // swap(arr, j, j + 1);
          [arr[j + 1], arr[j]] = [arr[j], arr[j + 1]];
        }
      }
    }
    return arr;
  }
  // 冒泡排序优化 对已排序的做标记、只排序未排的部分
  function bubbleSort1(arr) {
    let _count = 1;
    for (let i = 0; i < arr.length; i++) {
      for (let j = 0; j < arr.length - i; j++) {
        // 循环次数
        console.log('for _count', _count++);
        if (arr[j] < arr[j + 1]) {
          // 交换次数 最多 n(n-1)/2
          [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];//交换位置
        }
      }
    }
    return arr;
  }
  // test
  var arr = [91, 60, 96, 7, 35, 65, 10];
  console.log(bubbleSort(arr));

  // 快排 https://juejin.cn/post/6844903938290876430
  function quickSort(rawArr = []) {
    if (rawArr.length <= 1) { return rawArr; }
    // 排除掉分界点元素
    const leftArray = rawArr.filter((item, i) => item >= rawArr[0] && i !== 0);
    const rightArray = rawArr.filter(item => item < rawArr[0]);
    console.log('exec', leftArray, rightArray);
    return [...quickSort(leftArray), rawArr[0], ...quickSort(rightArray)];
  }
  var arr = [2,3,1,5,0];
  console.log(quickSort(arr));


  // 爬楼梯 f(x)=f(x−1)+f(x−2)
  // 斐波那契数列：前面相邻两项之和，构成了后一项。
  // [0, 1, 1, 2, 3, 5, 8, 13]
  function fibArr(n) {
    const fibs = [];
    let [pre, cur] = [0, 1];
    // 空间复杂度 O(1) 滚动数组法？ 动态规划法？
    for (let index = 1; index < n; index++) {
      [pre, cur] = [cur, pre + cur];
      fibs.push(cur);
    }
    return fibs;
  }
  console.log(fibArr(10));
  // 爬楼梯
  function climbStairs(n) {
    const fibs = [1, 2];
    // 空间复杂度 O(n) 动态规划法
    for (let index = 2; index < n; index++) {
      fibs[index] = fibs[index - 1] + fibs[index - 2];
    }
    return fibs;
  }

  function fibonacci(n) {
    if (n <= 2) {
      return 1;
    } else {
      const num = fibonacci(n - 1) + fibonacci(n - 2);
      return num;
    }
  }
  console.log(fibonacci(10));

  // leetcode 1. 两数之和  暴力破解法、hash 表法
  var twoSum = function(nums, target) {
    if (!nums || !nums.length) return;
    const hashObj = {};
    for (let index = 0; index < nums.length; index++) {
      const num = nums[index];
      const hasVal = hashObj[target - num];
      if (hasVal) {
        return [hasVal, index];
      }
      hashObj[num] = index;
    }
  };
  console.log('twoSum', twoSum([1,2,3,7,11,15], 9));

  // 876. 链表的中间结点

  // 136. 只出现一次的数字  位运算异或 时间复杂度：O(n)，空间复杂度：O(1)

  // 172. 阶乘后的零
  
  // leetcode 209. 长度最小的子数组
  // https://github.com/azl397985856/leetcode/blob/master/problems/209.minimum-size-subarray-sum.md
  
  // 汉诺塔问题 https://blog.csdn.net/lizhengxv/article/details/80043809
  
  // 20. 有效的括号 https://leetcode-cn.com/problems/valid-parentheses/

  // 53. 最大子序和

  // https://leetcode-cn.com/problems/length-of-longest-fibonacci-subsequence/
  // 动态规划 https://juejin.cn/post/6951922898638471181
  // 状态转移方程: 新加入一个元素nums[i], 最长递增子序列要么是以nums[i]结尾的递增子序列，要么就是nums[i-1]的最长递增子序列。
  // 最长斐波那契子序列
  var lenLongestFibSubseq = function (arr) {
    const len = arr.length;
    let ans = 0;
    const map = arr.reduce((pre, item, index) => ({
        ...pre,
        [item]: index + 1,
    }), {});
    // dp数组初始化为2
    const dp = new Array(len).fill().map(() => new Array(len).fill(2));
    console.log('map', map, dp);
    for (let j = len - 1; j >= 1; j--) {
        for (let i = j - 1; i >= 0; i--) {
            const sum = arr[i] + arr[j];
            if (map[sum]) {
              dp[i][j] = dp[j][map[sum] - 1] + 1;
            }
            ans = Math.max(dp[i][j], ans);
        }
    }
    return ans > 2 ? ans : 0;
  };
  const arr1 = [1,3,7,11,12,14,18]
  // const arr1 = [1,2,3,4,5,6,7,8];
  console.log(lenLongestFibSubseq(arr1));

</script>
</body>
</html>
